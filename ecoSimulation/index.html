<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”Ÿæ…‹æ¨¡æ“¬</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 15px; /* Reduced padding */
            background-color: #f4f7f6;
            color: #333;
            height: 100vh; /* Make body take full viewport height */
            overflow: hidden; /* Prevent body scrollbars for single page view */
        }
        h1 {
            color: #444;
            margin-top: 0;
            margin-bottom: 1px; /* Reduced margin */
            font-size: 1em;
        }
        .main-content {
            display: flex;
            gap: 15px; /* Reduced gap */
            width: 100%;
            max-width: 1400px; /* Allow wider layout */
            height: calc(100vh - 70px); /* Adjust based on h1 and padding */
        }
        .left-panel {
            display: flex;
            flex-direction: column;
            width: 300px; /* Fixed width for controls */
            flex-shrink: 0;
            gap: 10px;
        }
        .controls {
            padding: 5px; /* Reduced padding */
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto; /* Allow scroll within controls if needed */
            max-height: 100%; /* Ensure it fits within left-panel */
        }
        .controls h2 {
            margin-top: 0;
            margin-bottom: 5px;
            text-align: center;
            font-size: 1.2em;
        }
        .control-group {
            margin-bottom: 4px; /* Reduced margin */
            display: flex;
            /* flex-wrap: wrap; */ /* ç§»é™¤æˆ–è¨­ç‚º nowrap ä»¥é˜²æ­¢æ›è¡Œ */
            align-items: center;
        }
        .control-group label {
            font-weight: bold;
            font-size: 0.85em; /* Slightly smaller font */
            margin-right: 5px;
            flex-basis: 120px; /* Fixed basis for labels */
        }
        .control-group input[type="range"] {
            flex-grow: 1; /* Allow slider to take remaining space */
            height: 18px;
        }
        .control-group .value-display {
            font-size: 0.8em;
            width: 35px; /* Fixed width for value display */
            text-align: right;
            margin-left: 5px;
        }
        .control-group select,
        .control-group input[type="checkbox"] {
            margin-left: auto; /* Push select/checkbox to the right if label is short */
        }
         .control-group input[type="checkbox"] {
            transform: scale(0.9);
        }
        .species-controls-group {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            border: 1px solid #eee;
        }
        #unlimitedGrassControls { background-color: #90EE90; } /* Unlimited grass color */
        #limitedGrassControls { background-color: #66CDAA; }   /* Limited grass (edible) color */
        #sheepControls { background-color: #e0f2ff; }          /* Light blue for sheep - can be adjusted if needed */
        #rabbitControls { background-color: #f3e8ff; }         /* Light purple for rabbits - can be adjusted if needed */
        #wolfControls { background-color: #ffe0e0; }           /* Light red for wolves - can be adjusted if needed */

        .control-group input[type="range"]:disabled {
            opacity: 0.5;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        button {
            padding: 8px 10px; /* Reduced padding */
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em; /* Reduced font size */
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .right-panel {
            display: flex;
            flex-direction: row; /* æ”¹ç‚ºæ°´å¹³æ’åˆ— */
            flex-grow: 1;
            gap: 10px;
            min-width: 0; /* Important for flex item to shrink properly */
        }
        .simulation-area {
            flex: 1; /* ä½”æ“šå¯ç”¨ç©ºé–“çš„ä¸€åŠ */
            min-width: 0; /* å…è¨±ç¸®å° */
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            /* height: 100%; */ /* Flex items in a row stretch vertically by default */
        }
        canvas#simulationCanvas {
            border: 1px solid #ccc;
            /* Max width/height to fit, aspect ratio maintained by JS or fixed values */
            max-width: 100%;
            /* max-height: 350px; Removed, size will be controlled by flex-grow and aspect-ratio */
            flex-grow: 1; /* ç•«å¸ƒå°‡å¡«æ»¿ .simulation-area ä¸­çš„å‚ç›´å¯ç”¨ç©ºé–“ (æ¸›å» .stats çš„ç©ºé–“) */
            min-height: 0; /* é…åˆ flex-grow */
            aspect-ratio: 1 / 1; /* Keep it square */
            background-color: #e0ffe0;
        }
        .stats {
            margin-top: 8px;
            padding: 8px;
            background-color: #f9f9f9;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9em;
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0; /* é˜²æ­¢ .stats è¢«å£“ç¸® */
        }
        .stats span {
            margin: 0 8px;
        }
        .stats .stat-group {
            display: inline-flex; /* Changed to inline-flex for horizontal layout */
            align-items: center;
            padding: 3px 6px;
            margin: 0 2px; /* Reduced margin between groups */
            border-radius: 4px;
        }
        .stats .animal-stats, .stats .tick-stat {
             /* Optional: if you want a background for animal/tick stats too */
        }
        .stats .grass-stats-container {
            display: inline-flex; /* Keep grass stats together */
            align-items: center;
            margin: 0 2px; /* Add consistent margin with other stat groups */

        }
        .stats .grass-stat-item {
            display: inline-flex; /* Align color box and text */
            align-items: center;
            padding: 3px 6px;
            margin: 0 2px; /* Margin between individual grass stats */
            border-radius: 4px;
            font-size: 0.85em; /* Slightly smaller font for grass stats */
        }

        /* Styling for individual animal stat items */
        #sheepCountDisplay, #rabbitsCountDisplay, #wolvesCountDisplay {
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.85em; /* Consistent with grass items */
            margin: 0 1px; /* Small margin between animal items */
        }
        #sheepCountDisplay { background-color: #e0f2ff; } /* Matches #sheepControls */
        #rabbitsCountDisplay { background-color: #f3e8ff; } /* Matches #rabbitControls */
        #wolvesCountDisplay { background-color: #ffe0e0; } /* Matches #wolfControls */

        .chart-area {
            flex: 1; /* ä½”æ“šå¯ç”¨ç©ºé–“çš„ä¸€åŠ */
            min-width: 0; /* å…è¨±ç¸®å° */
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            /* min-height: 150px; Removed, height will be determined by flex parent */
        }
        .chart-toggle-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        .chart-toggle-buttons button {
            padding: 6px 12px;
            font-size: 0.85em;
            margin: 0 5px;
            background-color: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
        }
        .chart-toggle-buttons button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        /* .chart-area h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        } */
        canvas#populationChart, canvas#energyPyramidChart {
            width: 100%; 
            height: 100%; /* Ensure canvas tries to fill space before flex-grow */
            flex-grow: 1; /* Chart canvas takes available space in its container */
            min-height: 0; /* Allow shrinking for flex-grow */
        }
    </style>
</head>
<body>
    <h1>ç”Ÿæ…‹æ¨¡æ“¬</h1>
    <div class="main-content">
        <div class="left-panel">
            <div class="controls">
                <div class="control-group">
                    <label for="selectUnlimitedGrass" title="å•Ÿç”¨æˆ–åœç”¨ç„¡é™è‰(A)ã€‚ç„¡é™è‰æä¾›å›ºå®šèƒ½é‡ï¼Œä¸”ä¸æœƒè¢«åƒå…‰ã€‚">å•Ÿç”¨ç„¡é™è‰(A):</label>
                    <input type="checkbox" id="selectUnlimitedGrass" checked title="å‹¾é¸ä»¥å•Ÿç”¨ç„¡é™è‰(A)ã€‚">
                </div>
                <div id="unlimitedGrassControls" class="species-controls-group">
                    <div class="control-group">
                        <label for="energyFromUnlimitedGrass" title="è¨­å®šè‰é£Ÿå‹•ç‰©æ¯æ¬¡å¾ç„¡é™è‰(A)ä¸­ç²å–çš„èƒ½é‡å€¼ã€‚">ç„¡é™è‰Aç²èƒ½:</label>
                        <input type="range" id="energyFromUnlimitedGrass" min="1" max="10" value="2" step="1" title="èª¿æ•´è‰é£Ÿå‹•ç‰©å¾ç„¡é™è‰(A)ç²å–çš„èƒ½é‡ã€‚">
                        <span id="energyFromUnlimitedGrassValue" class="value-display">2</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="selectLimitedGrass" title="å•Ÿç”¨æˆ–åœç”¨æœ‰é™è‰(B)ã€‚æœ‰é™è‰æœƒè¢«åƒæ‰ï¼Œä¸¦éœ€è¦æ™‚é–“å†ç”Ÿï¼Œæœ‰æœ€å¤§è² è·é‡é™åˆ¶ã€‚">å•Ÿç”¨æœ‰é™è‰(B):</label>
                    <input type="checkbox" id="selectLimitedGrass" title="å‹¾é¸ä»¥å•Ÿç”¨æœ‰é™è‰(B)ã€‚">
                </div>
                <div id="limitedGrassControls" class="species-controls-group">
                    <div class="control-group">
                        <label for="energyFromLimitedGrass" title="è¨­å®šè‰é£Ÿå‹•ç‰©æ¯æ¬¡å¾æœ‰é™è‰(B)ä¸­ç²å–çš„èƒ½é‡å€¼ã€‚">æœ‰é™è‰Bç²èƒ½:</label>
                        <input type="range" id="energyFromLimitedGrass" min="1" max="20" value="4" step="1" title="èª¿æ•´è‰é£Ÿå‹•ç‰©å¾æœ‰é™è‰(B)ç²å–çš„èƒ½é‡ã€‚">
                        <span id="energyFromLimitedGrassValue" class="value-display">4</span>
                    </div>
                    <div class="control-group">
                        <label for="initialLimitedGrassPercent" title="è¨­å®šæ¨¡æ“¬é–‹å§‹æ™‚ï¼Œæœ‰é™è‰(B)åœ¨ç•«å¸ƒä¸Šçš„åˆå§‹è¦†è“‹ç™¾åˆ†æ¯”ã€‚">è‰Båˆå§‹è¦†è“‹%:</label>
                        <input type="range" id="initialLimitedGrassPercent" min="0" max="100" value="50" step="1" title="èª¿æ•´æœ‰é™è‰(B)çš„åˆå§‹è¦†è“‹ç‡ã€‚">
                        <span id="initialLimitedGrassPercentValue" class="value-display">50</span>
                    </div>
                    <div class="control-group">
                        <label for="grassRegrowthTime" title="è¨­å®šæœ‰é™è‰(B)è¢«åƒæ‰å¾Œï¼Œéœ€è¦å¤šå°‘å›åˆæ‰èƒ½é‡æ–°é•·å‡ºä¾†ã€‚">è‰Bå†ç”Ÿ(å›åˆ):</label>
                        <input type="range" id="grassRegrowthTime" min="1" max="100" value="30" title="èª¿æ•´æœ‰é™è‰(B)çš„å†ç”Ÿæ‰€éœ€å›åˆæ•¸ã€‚">
                        <span id="grassRegrowthTimeValue" class="value-display">30</span>
                    </div>
                    <div class="control-group">
                        <label for="grassCarryingCapacity" title="è¨­å®šåœ°åœ–ä¸Šæœ‰é™è‰(B)çš„æœ€å¤§ç¸½é‡ã€‚ç•¶è‰åœ°æ•¸é‡é”åˆ°æ­¤å€¼æ™‚ï¼Œä¸å†ç¹¼çºŒå†ç”Ÿï¼Œç›´åˆ°æœ‰è‰è¢«åƒæ‰ã€‚">è‰Bè² è·é‡:</label>
                        <input type="range" id="grassCarryingCapacity" min="100" max="2500" value="2000" step="50" title="èª¿æ•´æœ‰é™è‰(B)çš„æœ€å¤§è² è·é‡ã€‚">
                        <span id="grassCarryingCapacityValue" class="value-display">2000</span>
                    </div>
                </div>

                <hr style="margin: 8px 0; border-color: #eee;">

                <div class="control-group">
                    <label for="selectSheep" title="å•Ÿç”¨æˆ–åœç”¨ç¾Šç¾¤ã€‚">å•Ÿç”¨ç¾Šç¾¤:</label>
                    <input type="checkbox" id="selectSheep" checked title="å‹¾é¸ä»¥åœ¨æ¨¡æ“¬ä¸­åŒ…å«ç¾Šç¾¤ã€‚">
                </div>
                <div id="sheepControls" class="species-controls-group">
                    <div class="control-group">
                        <label for="initialNumberSheep" title="è¨­å®šæ¨¡æ“¬é–‹å§‹æ™‚ç¾Šçš„åˆå§‹æ•¸é‡ã€‚">åˆå§‹ç¾Šç¾¤:</label>
                        <input type="range" id="initialNumberSheep" min="0" max="500" value="100" title="èª¿æ•´åˆå§‹ç¾Šç¾¤æ•¸é‡ã€‚">
                        <span id="initialNumberSheepValue" class="value-display">100</span>
                    </div>
                    <div class="control-group">
                        <label for="sheepReproduce" title="è¨­å®šç¾Šæ¯å›åˆç¹æ®–çš„æ©Ÿç‡ç™¾åˆ†æ¯”ã€‚">ç¾Šç¹æ®–ç‡%:</label>
                        <input type="range" id="sheepReproduce" min="0" max="10" value="4" title="èª¿æ•´ç¾Šçš„ç¹æ®–æ©Ÿç‡ã€‚">
                        <span id="sheepReproduceValue" class="value-display">4</span>
                    </div>
                </div>

                <div class="control-group">
                    <label for="selectRabbit" title="å•Ÿç”¨æˆ–åœç”¨å…”ç¾¤ã€‚">å•Ÿç”¨å…”ç¾¤:</label>
                    <input type="checkbox" id="selectRabbit" title="å‹¾é¸ä»¥åœ¨æ¨¡æ“¬ä¸­åŒ…å«å…”ç¾¤ã€‚">
                </div>
                <div id="rabbitControls" class="species-controls-group">
                    <div class="control-group">
                        <label for="initialNumberRabbits" title="è¨­å®šæ¨¡æ“¬é–‹å§‹æ™‚å…”çš„åˆå§‹æ•¸é‡ã€‚">åˆå§‹å…”ç¾¤:</label>
                        <input type="range" id="initialNumberRabbits" min="0" max="500" value="0" title="èª¿æ•´åˆå§‹å…”ç¾¤æ•¸é‡ã€‚">
                        <span id="initialNumberRabbitsValue" class="value-display">0</span>
                    </div>
                    <div class="control-group">
                        <label for="rabbitReproduce" title="è¨­å®šå…”æ¯å›åˆç¹æ®–çš„æ©Ÿç‡ç™¾åˆ†æ¯”ã€‚">å…”ç¹æ®–ç‡%:</label>
                        <input type="range" id="rabbitReproduce" min="0" max="15" value="6" title="èª¿æ•´å…”çš„ç¹æ®–æ©Ÿç‡ã€‚">
                        <span id="rabbitReproduceValue" class="value-display">6</span>
                    </div>
                </div>

                <div class="control-group">
                    <label for="selectWolf" title="å•Ÿç”¨æˆ–åœç”¨ç‹¼ç¾¤ã€‚">å•Ÿç”¨ç‹¼ç¾¤:</label>
                    <input type="checkbox" id="selectWolf" title="å‹¾é¸ä»¥åœ¨æ¨¡æ“¬ä¸­åŒ…å«ç‹¼ç¾¤ã€‚">
                </div>
                <div id="wolfControls" class="species-controls-group">
                    <div class="control-group">
                        <label for="initialNumberWolves" title="è¨­å®šæ¨¡æ“¬é–‹å§‹æ™‚ç‹¼çš„åˆå§‹æ•¸é‡ã€‚">åˆå§‹ç‹¼ç¾¤:</label>
                        <input type="range" id="initialNumberWolves" min="0" max="250" value="50" title="èª¿æ•´åˆå§‹ç‹¼ç¾¤æ•¸é‡ã€‚">
                        <span id="initialNumberWolvesValue" class="value-display">50</span>
                    </div>
                    <div class="control-group">
                        <label for="wolfGainFromFood" title="è¨­å®šç‹¼æ¯æ¬¡æˆåŠŸæ•é£Ÿä¸€éš»ç¾Šå¾Œç²å¾—çš„èƒ½é‡å€¼ã€‚">ç‹¼(ç¾Š)ç²èƒ½:</label>
                        <input type="range" id="wolfGainFromFood" min="5" max="50" value="20" title="èª¿æ•´ç‹¼å¾ç¾Šç²å–çš„èƒ½é‡ã€‚">
                        <span id="wolfGainFromFoodValue" class="value-display">20</span>
                    </div>
                    <div class="control-group">
                        <label for="wolfGainFromRabbitFood" title="è¨­å®šç‹¼æ¯æ¬¡æˆåŠŸæ•é£Ÿä¸€éš»å…”å¾Œç²å¾—çš„èƒ½é‡å€¼ã€‚">ç‹¼(å…”)ç²èƒ½:</label>
                        <input type="range" id="wolfGainFromRabbitFood" min="1" max="30" value="10" title="èª¿æ•´ç‹¼å¾å…”ç²å–çš„èƒ½é‡ã€‚">
                        <span id="wolfGainFromRabbitFoodValue" class="value-display">10</span>
                    </div>
                    <div class="control-group">
                        <label for="wolfReproduce" title="è¨­å®šç‹¼æ¯å›åˆç¹æ®–çš„æ©Ÿç‡ç™¾åˆ†æ¯”ã€‚">ç‹¼ç¹æ®–ç‡%:</label>
                        <input type="range" id="wolfReproduce" min="0" max="10" value="5" title="èª¿æ•´ç‹¼çš„ç¹æ®–æ©Ÿç‡ã€‚">
                        <span id="wolfReproduceValue" class="value-display">5</span>
                    </div>
                </div>

                <hr style="margin: 8px 0; border-color: #eee;">
                <p style="font-size: 0.9em; text-align: center; margin: 2px 0;">é€šç”¨è¨­å®š:</p>

                <div class="control-group">
                    <label for="maxHerbivores" title="è¨­å®šè‰é£Ÿå‹•ç‰©(ç¾Šå’Œå…”çš„ç¸½å’Œ)çš„æœ€å¤§æ•¸é‡ä¸Šé™ã€‚ç•¶ç‹¼ç¾¤æ¶ˆå¤±ä¸”è‰é£Ÿå‹•ç‰©é”åˆ°æ­¤ä¸Šé™æ™‚ï¼Œæ¨¡æ“¬å°‡åœæ­¢ã€‚">è‰é£Ÿå‹•ç‰©è² è·é‡:</label>
                    <input type="range" id="maxHerbivores" min="500" max="10000" value="2000" step="100" title="èª¿æ•´è‰é£Ÿå‹•ç‰©çš„ç¸½æ•¸ä¸Šé™ã€‚">
                    <span id="maxHerbivoresValue" class="value-display">2000</span>
                </div>

                <div class="control-group">
                    <label for="showEnergy" title="åœ¨æ¨¡æ“¬ç•«é¢ä¸Šé¡¯ç¤ºæˆ–éš±è—æ¯å€‹ç”Ÿç‰©å€‹é«”çš„èƒ½é‡å€¼ã€‚">é¡¯ç¤ºèƒ½é‡:</label>
                    <input type="checkbox" id="showEnergy" title="å‹¾é¸ä»¥åœ¨ç”Ÿç‰©ä¸‹æ–¹é¡¯ç¤ºå…¶ç•¶å‰èƒ½é‡å€¼ã€‚">
                </div>
                <div class="control-group">
                    <label for="autoScaleYAxisCheckbox" title="è¨­å®šæ—ç¾¤å¤§å°è®ŠåŒ–åœ–çš„Yè»¸æ˜¯å¦è‡ªå‹•æ ¹æ“šæ•¸æ“šèª¿æ•´ç¯„åœï¼Œæˆ–ä½¿ç”¨å›ºå®šçš„å°æ•¸åˆ»åº¦èµ·é»ã€‚">Yè»¸è‡ªå‹•ç¸®æ”¾:</label>
                    <input type="checkbox" id="autoScaleYAxisCheckbox" title="å‹¾é¸ä»¥å•Ÿç”¨Yè»¸è‡ªå‹•ç¸®æ”¾ã€‚å–æ¶ˆå‹¾é¸å‰‡Yè»¸å¾0.1é–‹å§‹ã€‚">
                </div>

                <div class="control-group">
                    <label for="baseEnergyCostSlider" title="è¨­å®šæ‰€æœ‰ç”Ÿç‰©æ¯å›åˆç§»å‹•å’Œç¶­æŒç”Ÿå‘½æ‰€éœ€æ¶ˆè€—çš„åŸºç¤èƒ½é‡å€¼ã€‚">åŸºç¤è€—èƒ½/å›åˆ:</label>
                    <input type="range" id="baseEnergyCostSlider" min="0" max="5" value="1" step="1" title="èª¿æ•´ç”Ÿç‰©æ¯å›åˆçš„åŸºç¤èƒ½é‡æ¶ˆè€—ã€‚">
                    <span id="baseEnergyCostValue" class="value-display">1</span>
                </div>
                <div class="control-group">
                    <label for="reproductionEnergyCostFactorSlider" title="è¨­å®šç¹æ®–å¾Œèƒ½é‡çš„è¨ˆç®—æ–¹å¼ã€‚æ­¤æ•¸å€¼ç‚ºã€Œé™¤æ•¸ã€ï¼šç¹æ®–å¾Œèƒ½é‡ = åŸèƒ½é‡ Ã· æ­¤æ•¸å€¼ã€‚ä¾‹å¦‚ï¼šè¨­ç‚º 2ï¼Œç¹æ®–å¾Œèƒ½é‡æ¸›åŠ (æ¶ˆè€—50%èƒ½é‡)ï¼›è¨­ç‚º 4ï¼Œèƒ½é‡å‰©é¤˜1/4 (æ¶ˆè€—75%èƒ½é‡)ã€‚æ•¸å€¼è¶Šå°ï¼Œç¹æ®–æ™‚æ¶ˆè€—çš„èƒ½é‡è¶Šå°‘ã€‚">ç¹æ®–èƒ½é‡æˆæœ¬ (é™¤æ•¸):</label>
                    <input type="range" id="reproductionEnergyCostFactorSlider" min="1.1" max="4" value="2" step="0.1" title="èª¿æ•´ç¹æ®–èƒ½é‡æˆæœ¬çš„ã€Œé™¤æ•¸ã€ã€‚æ•¸å€¼è¶Šå°ï¼Œç¹æ®–æ¶ˆè€—çš„èƒ½é‡è¶Šå°‘ã€‚">
                    <span id="reproductionEnergyCostFactorValue" class="value-display">2</span>
                </div>
                <div class="button-group">
                    <button id="goContinuousButton" title="é€£çºŒé‹è¡Œæ¨¡æ“¬ï¼Œç›´åˆ°æ‰‹å‹•åœæ­¢æˆ–è§¸ç™¼åœæ­¢æ¢ä»¶ã€‚">é€£çºŒåŸ·è¡Œ</button>                    
                    <button id="goOnceButton" title="è®“æ¨¡æ“¬å‰é€²ä¸€å€‹å›åˆã€‚">å–®å›åˆåŸ·è¡Œ</button>                    
                    <button id="stopButton" disabled title="æš«åœæ­£åœ¨é€£çºŒé‹è¡Œçš„æ¨¡æ“¬ã€‚">åœæ­¢</button>
                    <button id="resetDefaultsButton" title="å°‡æ‰€æœ‰æ§åˆ¶é¢æ¿çš„è¨­å®šæ¢å¾©åˆ°é è¨­å€¼ï¼Œä¸¦é‡æ–°é–‹å§‹æ¨¡æ“¬æ–¼ç¬¬0å›åˆã€‚">é è¨­å€¼</button>

                </div>
                <div id="simulationMessages" style="text-align: center; margin-top: 10px; color: red; font-weight: bold; min-height: 1.2em;"></div>
            </div>
        </div>

        <div class="right-panel">
            <div class="simulation-area">
                <canvas id="simulationCanvas" width="450" height="450"></canvas> <!-- Fixed size or use JS to set based on available space -->
                <div class="stats">                    
                    <span id="ticksDisplay" class="stat-group tick-stat">å›åˆ: 0</span>
                    <span class="stat-group animal-stats">
                        <span id="rabbitsCountDisplay">å…”ç¾¤: N/A</span>                        
                        <span id="sheepCountDisplay">ç¾Šç¾¤: N/A</span>
                        <span id="wolvesCountDisplay">ç‹¼ç¾¤: N/A</span>
                    </span>
                    <div class="grass-stats-container">
                        <span id="unlimitedGrassStatDisplay" class="grass-stat-item" style="background-color: #cfe9cf;">
                            ç„¡é™è‰A: N/A
                        </span>
                        <span id="limitedGrassStatDisplay" class="grass-stat-item" style="background-color: #b2dfdb;">
                            æœ‰é™è‰B: 0
                        </span>
                    </div>
                </div>
            </div>
            <div class="chart-area">
                <div class="chart-toggle-buttons">
                    <button id="showPopulationChartButton" class="active" title="é¡¯ç¤ºå„æ—ç¾¤æ•¸é‡éš¨æ™‚é–“è®ŠåŒ–çš„æŠ˜ç·šåœ–ã€‚">æ—ç¾¤å¤§å°åœ–</button>
                    <button id="showEnergyPyramidButton" title="é¡¯ç¤ºç”Ÿç”¢è€…ã€åˆç´šæ¶ˆè²»è€…å’Œæ¬¡ç´šæ¶ˆè²»è€…çš„ç¸½èƒ½é‡æ¯”è¼ƒæ©«æ¢åœ–ã€‚">èƒ½é‡æ¯”è¼ƒ</button>
                </div>
                <canvas id="populationChart" style="display: block;"></canvas>
                <canvas id="energyPyramidChart" style="display: none;"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- Global Parameters & Configuration ---
        const simCanvasElement = document.getElementById('simulationCanvas');
        const ctx = simCanvasElement.getContext('2d');

        // Dynamic canvas sizing (optional, can be fixed in HTML/CSS)
        // let availableCanvasSize = Math.min(simCanvasElement.parentElement.offsetWidth - 20, simCanvasElement.parentElement.offsetHeight - 50); // 20 for padding, 50 for stats
        // availableCanvasSize = Math.max(200, availableCanvasSize); // Min size
        // simCanvasElement.width = availableCanvasSize;
        // simCanvasElement.height = availableCanvasSize;
        // For simplicity, using fixed size from HTML initially. If dynamic:
        // If you want to make the canvas truly responsive to the .simulation-area size,
        // you'd need to resize it in JS when the window resizes or when elements change.
        // For now, `aspect-ratio: 1/1` in CSS for `canvas#simulationCanvas` helps maintain it square.

        // --- Constants for Drawing and Simulation Logic ---
        const PATCH_COLOR_LIMITED_GRASS_PRESENT = '#66CDAA'; // æœ‰é™è‰B å­˜åœ¨æ™‚çš„é¡è‰²
        const PATCH_COLOR_LIMITED_GRASS_ABSENT = '#D2B48C';  // æœ‰é™è‰B ç¼ºä¹æ™‚çš„é¡è‰² (æ³¥åœŸè‰²)
        const PATCH_COLOR_UNLIMITED_GRASS = '#aadeaa';     // ç„¡é™è‰A çš„é¡è‰² (ç¨æš—ä»¥å¢åŠ å°æ¯”)
        const PATCH_COLOR_NO_GRASS = '#D3D3D3';            // æ²’æœ‰ä»»ä½•è‰ç¨®è¢«å•Ÿç”¨æ™‚çš„é¡è‰²
        
        const AGENT_FONT_SIZE_MULTIPLIER = 1; // Current user setting (patchSize * 2 for larger icons)
        const ENERGY_FONT_SIZE_MULTIPLIER = 0.5;

        const SHEEP_ICON = 'ğŸ‘';
        const WOLF_ICON = 'ğŸº';
        const RABBIT_ICON = 'ğŸ‡';

        const SHEEP_ENERGY_COLOR = 'blue';
        const WOLF_ENERGY_COLOR = 'red';
        const RABBIT_ENERGY_COLOR = 'purple';

        const PATCH_PCOLOR_GREEN = 'green'; // For internal logic (patch.pcolor value)
        const PATCH_PCOLOR_BROWN = 'brown'; // For internal logic (patch.pcolor value)
        const AGENT_CENTER_X_OFFSET = 0.5;        const AGENT_CENTER_Y_OFFSET = 0.5;        const ENERGY_TEXT_Y_OFFSET_FACTOR = 0.8; // For positioning energy text relative to patch top
        const worldWidth = 25; 
        const worldHeight = 25;
        let patchSize = simCanvasElement.width / worldWidth; // Recalculate if canvas size changes

        let config = {
            // Component selection
            hasUnlimitedGrass: true,
            hasLimitedGrass: false,
            hasSheep: true,
            hasRabbit: false,
            hasWolf: false,

            // Unlimited Grass (A)
            energyFromUnlimitedGrass: 2,

            // Limited Grass (B)
            energyFromLimitedGrass: 4, // Energy herbivores get from eating limited grass
            initialLimitedGrassPercent: 50, // New: Initial percentage of limited grass
            grassRegrowthTime: 30,
            grassCarryingCapacity: 2000,

            // Sheep
            initialNumberSheep: 100,
            sheepReproduce: 4,

            // Rabbit
            initialNumberRabbits: 0,
            rabbitReproduce: 6,

            // Wolf
            initialNumberWolves: 50,
            wolfGainFromFood: 20, // Energy from eating sheep
            wolfGainFromRabbitFood: 10, // Energy from eating rabbit
            wolfReproduce: 5,

            // General
            maxHerbivores: 2000, // Max combined sheep and rabbits
            showEnergy: false,
            autoScaleYAxis: false, // New: For chart Y-axis auto-scaling
            baseEnergyCost: 1, // New: Base energy cost per tick for all agents
            reproductionEnergyCostFactor: 2 // New: Energy is divided by this factor upon reproduction (e.g., 2 means 50% cost)
        };
        // Store the initial default configuration for the reset button
        const initialDefaultConfig = JSON.parse(JSON.stringify(config));

        let patches = [];
        let sheep = [];
        let wolves = [];
        let rabbits = []; // New: Array for rabbits        
        let ticks = 0;
        let simulationInterval = null;
        let simulationRunning = false;

        let currentVisibleChart = 'population'; // 'population' or 'energyPyramid'
        let populationChartInstance = null;
        let energyPyramidChartInstance = null;
        let chartData = {
            labels: [], 
            sheep: [], wolves: [], grass: [], rabbits: []
        };
        const MAX_CHART_POINTS = 300; // Reduced points for performance with faster updates

        // --- UI Elements ---
        // Checkboxes for selecting components
        const selectUnlimitedGrassCheckbox = document.getElementById('selectUnlimitedGrass');
        const selectLimitedGrassCheckbox = document.getElementById('selectLimitedGrass');
        const selectSheepCheckbox = document.getElementById('selectSheep');
        const selectRabbitCheckbox = document.getElementById('selectRabbit');
        const selectWolfCheckbox = document.getElementById('selectWolf');

        // Sliders for Unlimited Grass A
        const energyFromUnlimitedGrassSlider = document.getElementById('energyFromUnlimitedGrass');
        // Sliders for Limited Grass B
        const energyFromLimitedGrassSlider = document.getElementById('energyFromLimitedGrass');
        const initialLimitedGrassPercentSlider = document.getElementById('initialLimitedGrassPercent'); // New
        const grassRegrowthTimeSlider = document.getElementById('grassRegrowthTime');
        const grassCarryingCapacitySlider = document.getElementById('grassCarryingCapacity');
        // Sliders for Sheep
        const initialNumberSheepSlider = document.getElementById('initialNumberSheep');
        const sheepReproduceSlider = document.getElementById('sheepReproduce');
        // Sliders for Rabbit
        const initialNumberRabbitsSlider = document.getElementById('initialNumberRabbits');
        const rabbitReproduceSlider = document.getElementById('rabbitReproduce');
        // Sliders for Wolf
        const initialNumberWolvesSlider = document.getElementById('initialNumberWolves');
        const wolfGainFromFoodSlider = document.getElementById('wolfGainFromFood');
        const wolfGainFromRabbitFoodSlider = document.getElementById('wolfGainFromRabbitFood');
        const wolfReproduceSlider = document.getElementById('wolfReproduce');
        // General Sliders
        const autoScaleYAxisCheckbox = document.getElementById('autoScaleYAxisCheckbox'); // New
        const maxHerbivoresSlider = document.getElementById('maxHerbivores');
        const baseEnergyCostSlider = document.getElementById('baseEnergyCostSlider'); // New
        const reproductionEnergyCostFactorSlider = document.getElementById('reproductionEnergyCostFactorSlider'); // New


        const showEnergyCheckbox = document.getElementById('showEnergy');

        // const setupButton = document.getElementById('setupButton'); // Unused variable
        const goOnceButton = document.getElementById('goOnceButton');
        const goContinuousButton = document.getElementById('goContinuousButton');
        const stopButton = document.getElementById('stopButton');
        const resetDefaultsButton = document.getElementById('resetDefaultsButton');

        const ticksDisplay = document.getElementById('ticksDisplay');
        const sheepCountDisplay = document.getElementById('sheepCountDisplay');
        const wolvesCountDisplay = document.getElementById('wolvesCountDisplay');
        const rabbitsCountDisplay = document.getElementById('rabbitsCountDisplay'); // New
        const unlimitedGrassStatDisplay = document.getElementById('unlimitedGrassStatDisplay');
        const limitedGrassStatDisplay = document.getElementById('limitedGrassStatDisplay');
        
        // Chart toggle buttons
        const showPopulationChartButton = document.getElementById('showPopulationChartButton');
        const showEnergyPyramidButton = document.getElementById('showEnergyPyramidButton');
        const populationChartCanvasElement = document.getElementById('populationChart');
        const energyPyramidCanvasElement = document.getElementById('energyPyramidChart');
        const simulationMessagesElement = document.getElementById('simulationMessages');

        function displaySimulationMessage(message) {
            if (simulationMessagesElement) {
                simulationMessagesElement.textContent = message;
            }
        }
        function clearSimulationMessage() {
            if (simulationMessagesElement) simulationMessagesElement.textContent = '';
        }

        function setupSliderListener(sliderElement, valueDisplayId, configKey) {
            const valueDisplay = document.getElementById(valueDisplayId);
            sliderElement.addEventListener('input', () => {
                valueDisplay.textContent = sliderElement.value;
                config[configKey] = parseFloat(sliderElement.value);
                if (configKey === 'initialLimitedGrassPercent') updateInitialLimitedGrassVisuals(); // Real-time update for this slider
                // Real-time update for initial animal numbers
                if (['initialNumberSheep', 'initialNumberRabbits', 'initialNumberWolves'].includes(configKey)) {
                    updateInitialAnimalPopulations();
                }
            });
            valueDisplay.textContent = sliderElement.value; // Initialize
            config[configKey] = parseFloat(sliderElement.value); // Initialize
        }

        function setupCheckboxListener(checkboxElement, configKey, controlsGroupId) {
            checkboxElement.addEventListener('change', () => {
                config[configKey] = checkboxElement.checked;
                updateControlVisibility();
                // If simulation was set up, changing components might require re-setup
                if (patches.length > 0) {
                    // Consider stopping simulation or prompting for re-setup
                    // For now, just update chart visibility if applicable
                    if (populationChartInstance) {
                        // Current dataset order in initChart:
                        // 0: Limited Grass B
                        // 1: Rabbits
                        // 2: Sheep
                        // 3: Wolves
                        if (configKey === 'hasLimitedGrass') {
                            populationChartInstance.data.datasets[0].hidden = !config.hasLimitedGrass;
                        } else if (configKey === 'hasRabbit') {
                             populationChartInstance.data.datasets[1].hidden = !config.hasRabbit;
                        } else if (configKey === 'hasSheep') {
                            populationChartInstance.data.datasets[2].hidden = !config.hasSheep;
                        } else if (configKey === 'hasWolf') {
                            populationChartInstance.data.datasets[3].hidden = !config.hasWolf;
                        }
                        populationChartInstance.update('none');
                    }
                    updateDisplays();
                    if (configKey === 'hasLimitedGrass') updateInitialLimitedGrassVisuals(); // Update visuals when toggling limited grass
                    // Update animal populations when toggling species
                    if (['hasSheep', 'hasRabbit', 'hasWolf'].includes(configKey)) {
                        updateInitialAnimalPopulations();
                    }
                }
            });
            config[configKey] = checkboxElement.checked; // Initialize
        }

        function updateControlVisibility() {
            // Helper function to enable/disable controls within a group
            const setControlsDisabled = (groupId, isDisabled) => {
                const group = document.getElementById(groupId);
                if (group) {
                    group.querySelectorAll('input[type="range"], input[type="number"], select').forEach(input => {
                        input.disabled = isDisabled;
                    });
                }
            };

            setControlsDisabled('unlimitedGrassControls', !config.hasUnlimitedGrass);
            setControlsDisabled('limitedGrassControls', !config.hasLimitedGrass);
            setControlsDisabled('sheepControls', !config.hasSheep);
            setControlsDisabled('rabbitControls', !config.hasRabbit);
            setControlsDisabled('wolfControls', !config.hasWolf);
        }

        function updateInitialLimitedGrassVisuals() {
            if (patches.length === 0 || simulationRunning) return; // Only if world exists and not running

            // Re-seed limited grass based on the current percentage if it's enabled
            if (config.hasLimitedGrass) {
                for (let r = 0; r < worldWidth; r++) {
                    for (let c = 0; c < worldHeight; c++) {
                        if (patches[r] && patches[r][c]) { // Ensure patch exists
                            patches[r][c].pcolor = (Math.random() * 100 < config.initialLimitedGrassPercent) ? PATCH_PCOLOR_GREEN : PATCH_PCOLOR_BROWN;
                            patches[r][c].countdown = (patches[r][c].pcolor === PATCH_PCOLOR_GREEN) ? config.grassRegrowthTime : Math.floor(Math.random() * config.grassRegrowthTime);
                        }
                    }
                }
            }
            // If !config.hasLimitedGrass, the drawWorld function will handle rendering patches
            // as non-limited-grass (e.g., unlimited grass color or neutral).

            drawWorld();    // Redraw the world with the new grass distribution
            updateDisplays(); // Update the statistical displays
        }

        function updateInitialAnimalPopulations() {
            if (patches.length === 0 || simulationRunning) return; // Only if world exists and not running

            // Clear existing animal populations
            sheep = [];
            rabbits = [];
            wolves = [];

            // Re-populate based on current config, if enabled
            let sheepInitialEnergyMax = (config.energyFromLimitedGrass || config.energyFromUnlimitedGrass || 4) * 2;
            let rabbitInitialEnergyMax = (config.energyFromLimitedGrass || config.energyFromUnlimitedGrass || 3) * 2;
            let wolfInitialEnergyMax = (config.wolfGainFromFood || config.wolfGainFromRabbitFood || 20) * 2; // Consider both food sources for wolves

            if (config.hasSheep) {
                for (let i = 0; i < config.initialNumberSheep; i++) {
                    sheep.push(new Agent(Math.floor(Math.random() * worldWidth), Math.floor(Math.random() * worldHeight), Math.floor(Math.random() * sheepInitialEnergyMax), 'sheep'));
                }
            }
            if (config.hasRabbit) {
                for (let i = 0; i < config.initialNumberRabbits; i++) {
                    rabbits.push(new Agent(Math.floor(Math.random() * worldWidth), Math.floor(Math.random() * worldHeight), Math.floor(Math.random() * rabbitInitialEnergyMax), 'rabbit'));
                }
            }
            if (config.hasWolf) {
                for (let i = 0; i < config.initialNumberWolves; i++) {
                    wolves.push(new Agent(Math.floor(Math.random() * worldWidth), Math.floor(Math.random() * worldHeight), Math.floor(Math.random() * wolfInitialEnergyMax), 'wolf'));
                }
            }

            drawWorld();
            updateDisplays();
            // Update the current data point in the chart if it exists
            if (populationChartInstance && chartData.labels.length > 0) {
                const lastIndex = chartData.labels.length - 1;
                chartData.sheep[lastIndex] = sheep.length;
                chartData.rabbits[lastIndex] = rabbits.length;
                chartData.wolves[lastIndex] = wolves.length;
                populationChartInstance.update('none');
            }
        }

        function updateChartYAxisOptions() {
            if (!populationChartInstance) return;

            if (config.autoScaleYAxis) {
                populationChartInstance.options.scales.y.min = undefined; // Let Chart.js determine min based on data
                // populationChartInstance.options.scales.y.suggestedMax = undefined; // Let Chart.js determine max
            } else {
                populationChartInstance.options.scales.y.min = 0.1; // Fixed min for logarithmic scale
                // populationChartInstance.options.scales.y.suggestedMax = undefined; // Let Chart.js determine max
            }
            populationChartInstance.update('none');
        }


        // Setup Listeners for checkboxes
        setupCheckboxListener(selectUnlimitedGrassCheckbox, 'hasUnlimitedGrass', 'unlimitedGrassControls');
        setupCheckboxListener(selectLimitedGrassCheckbox, 'hasLimitedGrass', 'limitedGrassControls');
        setupCheckboxListener(selectSheepCheckbox, 'hasSheep', 'sheepControls');
        setupCheckboxListener(selectRabbitCheckbox, 'hasRabbit', 'rabbitControls');
        setupCheckboxListener(selectWolfCheckbox, 'hasWolf', 'wolfControls');

        // Setup Listeners for sliders
        setupSliderListener(energyFromUnlimitedGrassSlider, 'energyFromUnlimitedGrassValue', 'energyFromUnlimitedGrass');
        setupSliderListener(energyFromLimitedGrassSlider, 'energyFromLimitedGrassValue', 'energyFromLimitedGrass');
        setupSliderListener(initialLimitedGrassPercentSlider, 'initialLimitedGrassPercentValue', 'initialLimitedGrassPercent'); // New
        setupSliderListener(grassRegrowthTimeSlider, 'grassRegrowthTimeValue', 'grassRegrowthTime');
        setupSliderListener(grassCarryingCapacitySlider, 'grassCarryingCapacityValue', 'grassCarryingCapacity');
        setupSliderListener(initialNumberSheepSlider, 'initialNumberSheepValue', 'initialNumberSheep');
        setupSliderListener(sheepReproduceSlider, 'sheepReproduceValue', 'sheepReproduce');
        setupSliderListener(initialNumberRabbitsSlider, 'initialNumberRabbitsValue', 'initialNumberRabbits');
        setupSliderListener(rabbitReproduceSlider, 'rabbitReproduceValue', 'rabbitReproduce');
        setupSliderListener(initialNumberWolvesSlider, 'initialNumberWolvesValue', 'initialNumberWolves');
        setupSliderListener(wolfGainFromFoodSlider, 'wolfGainFromFoodValue', 'wolfGainFromFood');
        setupSliderListener(wolfGainFromRabbitFoodSlider, 'wolfGainFromRabbitFoodValue', 'wolfGainFromRabbitFood');
        setupSliderListener(wolfReproduceSlider, 'wolfReproduceValue', 'wolfReproduce');
        setupSliderListener(maxHerbivoresSlider, 'maxHerbivoresValue', 'maxHerbivores');
        setupSliderListener(baseEnergyCostSlider, 'baseEnergyCostValue', 'baseEnergyCost'); // New
        setupSliderListener(reproductionEnergyCostFactorSlider, 'reproductionEnergyCostFactorValue', 'reproductionEnergyCostFactor'); // New

        showEnergyCheckbox.addEventListener('change', () => {
            config.showEnergy = showEnergyCheckbox.checked;
            if (patches.length > 0) drawWorld(); 
        });

        autoScaleYAxisCheckbox.addEventListener('change', () => {
            config.autoScaleYAxis = autoScaleYAxisCheckbox.checked;
            updateChartYAxisOptions();
        });

        class Agent { // Same as before
            constructor(x, y, energy, type) {
                this.x = x; this.y = y; this.energy = energy; this.type = type;
                this.id = Math.random().toString(36).substr(2, 9);
            }
            move() {
                let angle = Math.random() * 360;
                let dx = Math.round(Math.cos(angle * Math.PI / 180));
                let dy = Math.round(Math.sin(angle * Math.PI / 180));
                this.x = (this.x + dx + worldWidth + worldWidth) % worldWidth; // Double worldWidth for robust modulo
                this.y = (this.y + dy + worldHeight + worldHeight) % worldHeight;
            }
        }

        function calculateCurrentGrassCount() { // Same as before
            if (!config.hasLimitedGrass || !patches.length) return 0;
            let count = 0;
            for (let r = 0; r < worldWidth; r++) {
                for (let c = 0; c < worldHeight; c++) {
                    if (patches[r] && patches[r][c] && patches[r][c].pcolor === PATCH_PCOLOR_GREEN) count++;
                }
            }
            return count;
        }

        function initPopulationChart() { 
            if (populationChartInstance) populationChartInstance.destroy();
            // const chartCanvas = document.getElementById('populationChart'); // Already defined as populationChartCanvasElement
            const ctxPopChart = populationChartCanvasElement.getContext('2d');
            populationChartInstance = new Chart(ctxPopChart, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [
                        { label: 'æœ‰é™è‰B', data: chartData.grass, borderColor: 'rgb(75, 192, 75)', backgroundColor: 'rgba(75, 192, 75, 0.1)', tension: 0.1, hidden: !config.hasLimitedGrass, pointRadius: 0, borderWidth: 1.5 },                    
                        { label: 'å…”ç¾¤', data: chartData.rabbits, borderColor: 'rgb(153, 102, 255)', backgroundColor: 'rgba(153, 102, 255, 0.1)', tension: 0.1, pointRadius: 0, borderWidth: 1.5, hidden: !config.hasRabbit },                        
                        { label: 'ç¾Šç¾¤', data: chartData.sheep, borderColor: 'rgb(54, 162, 235)', backgroundColor: 'rgba(54, 162, 235, 0.1)', tension: 0.1, pointRadius: 0, borderWidth: 1.5, hidden: !config.hasSheep },
                        { label: 'ç‹¼ç¾¤', data: chartData.wolves, borderColor: 'rgb(255, 99, 132)', backgroundColor: 'rgba(255, 99, 132, 0.1)', tension: 0.1, pointRadius: 0, borderWidth: 1.5, hidden: !config.hasWolf }
                    ]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false, },
                    scales: {
                        x: { title: { display: true, text: 'æ¨¡æ“¬å›åˆ', font: {size: 10} }, ticks: { font: {size: 9} } },
                        y: { 
                            type: 'logarithmic', 
                            display: true, 
                            title: { display: true, text: 'æ—ç¾¤æ•¸é‡ (å°æ•¸)', font: {size: 10} }, 
                            min: config.autoScaleYAxis ? undefined : 0.1, // Set min based on config
                            // suggestedMax: will be auto-calculated by Chart.js
                            ticks: { font: {size: 9}, callback: function(value, index, values) { if (value === 0.1 || value === 1 || value === 10 || value === 100 || value === 1000 || value === 10000) return value; } } 
                        }
                    },
                    plugins: { 
                        title: { display: true, text: 'æ—ç¾¤å¤§å°è®ŠåŒ–åœ–', font: {size: 14} }, 
                        legend: { position: 'top', labels: { font: {size: 10}, boxWidth: 20, padding: 10 } } 
                    },
                    animation: { duration: 0 }, // Disable animation for faster updates
                    elements: { line: { borderWidth: 1.5 } }
                }
            });
        }

        function initEnergyPyramidChart() {
            if (energyPyramidChartInstance) energyPyramidChartInstance.destroy();
            const ctxEnergyChart = energyPyramidCanvasElement.getContext('2d');

            const energies = calculateTrophicEnergies();

            energyPyramidChartInstance = new Chart(ctxEnergyChart, {
                type: 'bar',
                data: {
                    labels: ['æ¬¡ç´šæ¶ˆè²»è€… (ç‹¼)', 'åˆç´šæ¶ˆè²»è€… (ç¾Š+å…”)', 'ç”Ÿç”¢è€… (è‰B)'],
                    datasets: [{
                        label: 'ç¸½èƒ½é‡',
                        data: [energies.secondaryConsumer, energies.primaryConsumer, energies.producer],
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.7)',  // Red for secondary consumers
                            'rgba(255, 159, 64, 0.7)', // Orange for primary consumers
                            'rgba(75, 192, 75, 0.7)',  // Green for producers
                        ],
                        borderColor: [
                            'rgb(255, 99, 132)',
                            'rgb(255, 159, 64)',
                            'rgb(75, 192, 75)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y', // Makes it a horizontal bar chart
                    responsive: true, maintainAspectRatio: false,
                    scales: { x: { beginAtZero: true, title: { display: true, text: 'ç¸½èƒ½é‡å–®ä½', font: {size: 10} } }, y: { ticks: { font: {size: 10} } } },
                    plugins: { title: { display: true, text: 'èƒ½é‡æ©«æ¢åœ–', font: {size: 14} }, legend: { display: false } },
                    animation: { duration: 0 }
                }
            });
        }
        
        function setup() {
            stopSimulation();
            clearSimulationMessage();
            patchSize = simCanvasElement.width / worldWidth; 
            ticks = 0; sheep = []; wolves = []; rabbits = []; patches = []; // Initialize rabbits array

            for (let i = 0; i < worldWidth; i++) {
                patches[i] = [];
                for (let j = 0; j < worldHeight; j++) {
                    let pcolorValue, countdown;
                    if (config.hasLimitedGrass) { // Use initialLimitedGrassPercent for initial setup
                        pcolorValue = (Math.random() * 100 < config.initialLimitedGrassPercent) ? PATCH_PCOLOR_GREEN : PATCH_PCOLOR_BROWN;
                        countdown = (pcolorValue === PATCH_PCOLOR_GREEN) ? config.grassRegrowthTime : Math.floor(Math.random() * config.grassRegrowthTime);
                    } else { // If no limited grass, patches are neutral (e.g., for unlimited grass or just space)
                        pcolorValue = PATCH_PCOLOR_BROWN; // Or a neutral color like '#E0E0E0'
                        countdown = 0; 
                    }
                    patches[i][j] = { pcolor: pcolorValue, countdown: countdown };
                }
            }

            let sheepInitialEnergyMax = (config.energyFromLimitedGrass || config.energyFromUnlimitedGrass || 4) * 2;
            let rabbitInitialEnergyMax = (config.energyFromLimitedGrass || config.energyFromUnlimitedGrass || 3) * 2;
            let wolfInitialEnergyMax = (config.wolfGainFromFood || 20) * 2;

            if (config.hasSheep) {
                for (let i = 0; i < config.initialNumberSheep; i++) {
                    sheep.push(new Agent(Math.floor(Math.random() * worldWidth), Math.floor(Math.random() * worldHeight), Math.floor(Math.random() * sheepInitialEnergyMax), 'sheep'));
                }
            }
            if (config.hasRabbit && config.initialNumberRabbits > 0) {
                for (let i = 0; i < config.initialNumberRabbits; i++) {
                    rabbits.push(new Agent(Math.floor(Math.random() * worldWidth), Math.floor(Math.random() * worldHeight), Math.floor(Math.random() * rabbitInitialEnergyMax), 'rabbit'));
                }
            }
            if (config.hasWolf) {
                for (let i = 0; i < config.initialNumberWolves; i++) {
                    wolves.push(new Agent(Math.floor(Math.random() * worldWidth), Math.floor(Math.random() * worldHeight), Math.floor(Math.random() * wolfInitialEnergyMax), 'wolf'));
                }
            }
            
            if (currentVisibleChart === 'population') {
                chartData.labels = [ticks]; 
                chartData.sheep = [sheep.length]; 
                chartData.wolves = [wolves.length]; 
                chartData.rabbits = [rabbits.length];
                chartData.grass = [config.hasLimitedGrass ? calculateCurrentGrassCount() : 0];
                
                if (!populationChartInstance) initPopulationChart();
                else { 
                    populationChartInstance.data.labels = chartData.labels;
                    populationChartInstance.data.datasets[0].data = chartData.grass; 
                    populationChartInstance.data.datasets[1].data = chartData.rabbits; 
                    populationChartInstance.data.datasets[2].data = chartData.sheep;
                    populationChartInstance.data.datasets[3].data = chartData.wolves;

                    populationChartInstance.data.datasets[0].hidden = !config.hasLimitedGrass;
                    populationChartInstance.data.datasets[1].hidden = !config.hasRabbit;
                    populationChartInstance.data.datasets[2].hidden = !config.hasSheep;
                    populationChartInstance.data.datasets[3].hidden = !config.hasWolf;
                    populationChartInstance.update('none');
                }
            } else if (currentVisibleChart === 'energyPyramid') {
                if (!energyPyramidChartInstance) initEnergyPyramidChart();
                else updateEnergyPyramidChartData();
            }
            
            updateDisplays(); drawWorld(); enableButtonsAfterSetup();
        }
        function resetToDefaults() {
            stopSimulation(); // Stop simulation if running

            // Apply defaults to config object first by creating a deep copy
            Object.assign(config, JSON.parse(JSON.stringify(initialDefaultConfig)));

            // Update UI elements from the now-reset config and trigger their events
            // Checkboxes
            selectUnlimitedGrassCheckbox.checked = config.hasUnlimitedGrass;
            selectUnlimitedGrassCheckbox.dispatchEvent(new Event('change'));
            selectLimitedGrassCheckbox.checked = config.hasLimitedGrass;
            selectLimitedGrassCheckbox.dispatchEvent(new Event('change'));
            selectSheepCheckbox.checked = config.hasSheep;
            selectSheepCheckbox.dispatchEvent(new Event('change'));
            selectRabbitCheckbox.checked = config.hasRabbit;
            selectRabbitCheckbox.dispatchEvent(new Event('change'));
            selectWolfCheckbox.checked = config.hasWolf;
            selectWolfCheckbox.dispatchEvent(new Event('change'));
            showEnergyCheckbox.checked = config.showEnergy;
            showEnergyCheckbox.dispatchEvent(new Event('change'));
            autoScaleYAxisCheckbox.checked = config.autoScaleYAxis;
            autoScaleYAxisCheckbox.dispatchEvent(new Event('change'));

            // Sliders - set value, then dispatch 'input' to update display span and config (via listener)
            const slidersToReset = [
                { el: energyFromUnlimitedGrassSlider, key: 'energyFromUnlimitedGrass' },
                { el: energyFromLimitedGrassSlider, key: 'energyFromLimitedGrass' },
                { el: initialLimitedGrassPercentSlider, key: 'initialLimitedGrassPercent' },
                { el: grassRegrowthTimeSlider, key: 'grassRegrowthTime' },
                { el: grassCarryingCapacitySlider, key: 'grassCarryingCapacity' },
                { el: initialNumberSheepSlider, key: 'initialNumberSheep' },
                { el: sheepReproduceSlider, key: 'sheepReproduce' },
                { el: initialNumberRabbitsSlider, key: 'initialNumberRabbits' },
                { el: rabbitReproduceSlider, key: 'rabbitReproduce' },
                { el: initialNumberWolvesSlider, key: 'initialNumberWolves' },
                { el: wolfGainFromFoodSlider, key: 'wolfGainFromFood' },
                { el: wolfGainFromRabbitFoodSlider, key: 'wolfGainFromRabbitFood' },
                { el: wolfReproduceSlider, key: 'wolfReproduce' },
                { el: maxHerbivoresSlider, key: 'maxHerbivores' },
                { el: baseEnergyCostSlider, key: 'baseEnergyCost' }, // New
                { el: reproductionEnergyCostFactorSlider, key: 'reproductionEnergyCostFactor' } // New
            ];
            slidersToReset.forEach(item => {
                item.el.value = config[item.key];
                item.el.dispatchEvent(new Event('input'));
            });

            // Call setup() to completely re-initialize the simulation world
            // based on the now-default config values. This resets ticks to 0,
            // clears and re-populates animals/patches, resets the chart, etc.
            setup();

            // Inform the user. setup() calls updateDisplays() and drawWorld().
            // alert("æ‰€æœ‰è¨­å®šå·²é‡ç½®ç‚ºé è¨­å€¼ï¼Œæ¨¡æ“¬å·²é‡æ–°é–‹å§‹æ–¼ç¬¬0å›åˆã€‚\næ‚¨å¯ä»¥ç›´æ¥é–‹å§‹æ¨¡æ“¬æˆ–ç¹¼çºŒèª¿æ•´ã€‚");
            displaySimulationMessage("æ‰€æœ‰è¨­å®šå·²é‡ç½®ç‚ºé è¨­å€¼ï¼Œæ¨¡æ“¬å·²é‡æ–°é–‹å§‹æ–¼ç¬¬0å›åˆã€‚");
        }

        function calculateTrophicEnergies() {
            const producerEnergy = config.hasLimitedGrass ? calculateCurrentGrassCount() * config.energyFromLimitedGrass : 0;
            
            const sheepEnergy = config.hasSheep ? sheep.reduce((sum, s) => sum + Math.max(0, s.energy), 0) : 0;
            const rabbitEnergy = config.hasRabbit ? rabbits.reduce((sum, r) => sum + Math.max(0, r.energy), 0) : 0;
            const primaryConsumerEnergy = sheepEnergy + rabbitEnergy;

            const secondaryConsumerEnergy = config.hasWolf ? wolves.reduce((sum, w) => sum + Math.max(0, w.energy), 0) : 0;

            return { producer: producerEnergy, primaryConsumer: primaryConsumerEnergy, secondaryConsumer: secondaryConsumerEnergy };
        }

        function go() {
            let activeAnimalTypes = (config.hasSheep && sheep.length > 0) || 
                                  (config.hasRabbit && rabbits.length > 0) || 
                                  (config.hasWolf && wolves.length > 0);
            let anySelectableAnimalExists = (config.hasSheep && sheep.length > 0) ||
                                          (config.hasRabbit && rabbits.length > 0) ||
                                          (config.hasWolf && wolves.length > 0);
            let anyAnimalSelected = config.hasSheep || config.hasRabbit || config.hasWolf;

            if (anyAnimalSelected && !anySelectableAnimalExists) {
                //  alert("æ‰€æœ‰é¸å®šçš„å‹•ç‰©éƒ½æ¶ˆå¤±äº†ï¼Œæ¨¡æ“¬åœæ­¢ã€‚"); 
                 displaySimulationMessage("æ‰€æœ‰é¸å®šçš„å‹•ç‰©éƒ½æ¶ˆå¤±äº†ï¼Œæ¨¡æ“¬åœæ­¢ã€‚");
                 stopSimulation(); return;
            }

            let totalHerbivores = (config.hasSheep ? sheep.length : 0) + (config.hasRabbit ? rabbits.length : 0);
            let wolvesEffectivelyExtinct = config.hasWolf ? wolves.length === 0 : true;

            if (wolvesEffectivelyExtinct && totalHerbivores > config.maxHerbivores && (config.hasSheep || config.hasRabbit)) {
                displaySimulationMessage("è‰é£Ÿå‹•ç‰©æ•¸é‡éå¤šï¼Œç‰ å€‘ä½”æ»¿äº†é€™ç‰‡åœŸåœ°ï¼æ¨¡æ“¬åœæ­¢ã€‚"); stopSimulation(); return;
            }

            // Sheep logic (if sheep are enabled)
            if (config.hasSheep) {
                for (let i = sheep.length - 1; i >= 0; i--) {
                    const s = sheep[i]; s.move();
                    s.energy -= config.baseEnergyCost; // Use configured base cost
                    let energyGainedThisTurn = 0;
                    if (config.hasLimitedGrass) {
                        const patch = patches[s.x][s.y];
                        if (patch.pcolor === PATCH_PCOLOR_GREEN) { patch.pcolor = PATCH_PCOLOR_BROWN; patch.countdown = config.grassRegrowthTime; energyGainedThisTurn += config.energyFromLimitedGrass; }
                    }
                    if (energyGainedThisTurn === 0 && config.hasUnlimitedGrass) {
                        energyGainedThisTurn += config.energyFromUnlimitedGrass;
                    }
                    s.energy += energyGainedThisTurn;

                    if (s.energy < 0) { sheep.splice(i, 1); continue; }
                    
                    let currentTotalHerbivoresForSheepRepro = (config.hasSheep ? sheep.length : 0) + (config.hasRabbit ? rabbits.length : 0);
                    if (Math.random() * 100 < config.sheepReproduce) {
                        if (currentTotalHerbivoresForSheepRepro < config.maxHerbivores) {
                            s.energy /= config.reproductionEnergyCostFactor; // Use configured reproduction cost
                            const offspring = new Agent(s.x, s.y, s.energy, 'sheep'); 
                            offspring.move(); sheep.push(offspring);
                        }
                    }
                }
            }
            // Rabbit logic (if rabbits are enabled)
            if (config.hasRabbit) { 
                for (let i = rabbits.length - 1; i >= 0; i--) {
                    const r = rabbits[i];
                    r.move();
                    r.energy -= config.baseEnergyCost; // Use configured base cost
                    let energyGainedThisTurn = 0;
                    if (config.hasLimitedGrass) {
                        const patch = patches[r.x][r.y];
                        if (patch.pcolor === PATCH_PCOLOR_GREEN) {
                            patch.pcolor = PATCH_PCOLOR_BROWN;
                            patch.countdown = config.grassRegrowthTime;
                            energyGainedThisTurn += config.energyFromLimitedGrass; // Rabbits also eat limited grass
                        }
                    }
                    if (energyGainedThisTurn === 0 && config.hasUnlimitedGrass) {
                        energyGainedThisTurn += config.energyFromUnlimitedGrass;
                    }
                    r.energy += energyGainedThisTurn;

                    if (r.energy < 0) { rabbits.splice(i, 1); continue; }

                    let currentTotalHerbivoresForRabbitRepro = (config.hasSheep ? sheep.length : 0) + (config.hasRabbit ? rabbits.length : 0);
                    if (Math.random() * 100 < config.rabbitReproduce) {
                        if (currentTotalHerbivoresForRabbitRepro < config.maxHerbivores) {
                            r.energy /= config.reproductionEnergyCostFactor; // Use configured reproduction cost
                            const offspring = new Agent(r.x, r.y, r.energy, 'rabbit');
                            offspring.move();
                            rabbits.push(offspring);
                        }
                    }
                }
            }
            
            // Wolves logic (if wolves are enabled)
            if (config.hasWolf) {
                for (let i = wolves.length - 1; i >= 0; i--) {
                    const w = wolves[i]; w.move(); 
                    w.energy -= config.baseEnergyCost; // Use configured base cost
                    let ate = false;
                    // Try to eat sheep first (if sheep are enabled and exist)
                    if (config.hasSheep && sheep.length > 0) {
                        for (let j = sheep.length - 1; j >= 0; j--) {
                            if (sheep[j].x === w.x && sheep[j].y === w.y) { sheep.splice(j, 1); w.energy += config.wolfGainFromFood; ate = true; break; }
                        }
                    }
                    // If no sheep eaten, try to eat rabbit (if rabbits are enabled and exist)
                    if (!ate && config.hasRabbit && rabbits.length > 0) {
                        for (let k = rabbits.length - 1; k >= 0; k--) {
                            if (rabbits[k].x === w.x && rabbits[k].y === w.y) { rabbits.splice(k, 1); w.energy += config.wolfGainFromRabbitFood; ate = true; break; }
                        }
                    }
                    if (w.energy < 0) { wolves.splice(i, 1); continue; }
                    if (Math.random() * 100 < config.wolfReproduce) {
                        w.energy /= config.reproductionEnergyCostFactor; // Use configured reproduction cost
                        const offspring = new Agent(w.x, w.y, w.energy, 'wolf'); 
                        offspring.move(); wolves.push(offspring);
                    }
                }
            }
            // Patch logic (Limited Grass B Regrowth with Carrying Capacity)
            if (config.hasLimitedGrass) {
                for (let r = 0; r < worldWidth; r++) for (let c = 0; c < worldHeight; c++) {
                    const patch = patches[r][c];
                    if (patch.pcolor === PATCH_PCOLOR_BROWN) { 
                        patch.countdown--; 
                        if (patch.countdown <= 0 && calculateCurrentGrassCount() < config.grassCarryingCapacity) {
                            patch.pcolor = PATCH_PCOLOR_GREEN; 
                        }
                    }
                }
            }
            ticks++;
            
            if (currentVisibleChart === 'population') {
                chartData.labels.push(ticks); 
                chartData.sheep.push(sheep.length); 
                chartData.wolves.push(wolves.length);
                chartData.grass.push(config.hasLimitedGrass ? calculateCurrentGrassCount() : 0);
                chartData.rabbits.push(rabbits.length);
                if (chartData.labels.length > MAX_CHART_POINTS) { chartData.labels.shift(); chartData.sheep.shift(); chartData.wolves.shift(); chartData.grass.shift(); chartData.rabbits.shift(); }
                if (populationChartInstance) populationChartInstance.update('none');
            } else if (currentVisibleChart === 'energyPyramid') {
                if (energyPyramidChartInstance) updateEnergyPyramidChartData();
            }


            updateDisplays(); drawWorld();
            // Termination checks are now at the beginning of go()
        }

        function drawWorld() { // Drawing logic largely the same
            ctx.clearRect(0, 0, simCanvasElement.width, simCanvasElement.height);
            for (let r = 0; r < worldWidth; r++) for (let c = 0; c < worldHeight; c++) {
                const patch = patches[r][c];
                ctx.fillStyle = (patch.pcolor === PATCH_PCOLOR_GREEN) ? PATCH_COLOR_LIMITED_GRASS_PRESENT : PATCH_COLOR_LIMITED_GRASS_ABSENT;
                if (!config.hasLimitedGrass && config.hasUnlimitedGrass) { // If only unlimited grass, make it look always green
                    ctx.fillStyle = PATCH_COLOR_UNLIMITED_GRASS; 
                } else if (!config.hasLimitedGrass && !config.hasUnlimitedGrass) {
                    ctx.fillStyle = PATCH_COLOR_NO_GRASS; 
                }
                ctx.fillRect(r * patchSize, c * patchSize, patchSize, patchSize);
            }
            const agentFontSize = patchSize * AGENT_FONT_SIZE_MULTIPLIER;
            const energyFontSize = patchSize * ENERGY_FONT_SIZE_MULTIPLIER;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

            if (config.hasSheep) {
                sheep.forEach(s => {
                    ctx.font = `${agentFontSize}px Arial`;
                    ctx.fillText(SHEEP_ICON, (s.x + AGENT_CENTER_X_OFFSET) * patchSize, (s.y + AGENT_CENTER_Y_OFFSET) * patchSize);
                    if (config.showEnergy) {
                        ctx.fillStyle = SHEEP_ENERGY_COLOR; ctx.font = `${energyFontSize}px Arial`;
                        ctx.fillText(Math.round(s.energy), (s.x + AGENT_CENTER_X_OFFSET) * patchSize, (s.y + ENERGY_TEXT_Y_OFFSET_FACTOR) * patchSize);
                    }
                });
            }
            if (config.hasWolf) {
                wolves.forEach(w => {
                    ctx.font = `${agentFontSize}px Arial`;
                    ctx.fillText(WOLF_ICON, (w.x + AGENT_CENTER_X_OFFSET) * patchSize, (w.y + AGENT_CENTER_Y_OFFSET) * patchSize);
                    if (config.showEnergy) {
                        ctx.fillStyle = WOLF_ENERGY_COLOR; ctx.font = `${energyFontSize}px Arial`;
                        ctx.fillText(Math.round(w.energy), (w.x + AGENT_CENTER_X_OFFSET) * patchSize, (w.y + ENERGY_TEXT_Y_OFFSET_FACTOR) * patchSize);
                    }
                });
            }
            if (config.hasRabbit) {
                rabbits.forEach(r => { 
                    ctx.font = `${agentFontSize}px Arial`;
                    ctx.fillText(RABBIT_ICON, (r.x + AGENT_CENTER_X_OFFSET) * patchSize, (r.y + AGENT_CENTER_Y_OFFSET) * patchSize);
                    if (config.showEnergy) {
                        ctx.fillStyle = RABBIT_ENERGY_COLOR; ctx.font = `${energyFontSize}px Arial`; // Ensure energyFontSize is updated if multiplier changes
                        ctx.fillText(Math.round(r.energy), (r.x + AGENT_CENTER_X_OFFSET) * patchSize, (r.y + ENERGY_TEXT_Y_OFFSET_FACTOR) * patchSize);
                    }
                });
            }
        }

        function updateDisplays() { 
            ticksDisplay.textContent = `å›åˆ: ${ticks}`;
            unlimitedGrassStatDisplay.textContent = `ç„¡é™è‰A: ${config.hasUnlimitedGrass ? `ä¾›æ‡‰ä¸­` : 'åœç”¨'}`;
            const grassVal = calculateCurrentGrassCount();
            limitedGrassStatDisplay.textContent = `æœ‰é™è‰B: ${config.hasLimitedGrass ? grassVal : (config.hasLimitedGrass === false ? 'åœç”¨' : 0)}`; // Show 0 if enabled but empty, else "åœç”¨"
            rabbitsCountDisplay.textContent = `å…”ç¾¤: ${config.hasRabbit ? rabbits.length : 0}`;                        
            sheepCountDisplay.textContent = `ç¾Šç¾¤: ${config.hasSheep ? sheep.length : 0}`;
            wolvesCountDisplay.textContent = `ç‹¼ç¾¤: ${config.hasWolf ? wolves.length : 0}`;


        }

        function updateEnergyPyramidChartData() {
            if (!energyPyramidChartInstance) return;
            const energies = calculateTrophicEnergies();
            energyPyramidChartInstance.data.datasets[0].data[0] = energies.secondaryConsumer;
            energyPyramidChartInstance.data.datasets[0].data[1] = energies.primaryConsumer;
            energyPyramidChartInstance.data.datasets[0].data[2] = energies.producer;
            energyPyramidChartInstance.update('none');
        }
        function startSimulation() { 
            if (simulationRunning) return;
            clearSimulationMessage();
            simulationRunning = true;
            goContinuousButton.textContent = "é‹è¡Œä¸­"; goContinuousButton.disabled = true;
            goOnceButton.disabled = true; /* setupButton removed */ stopButton.disabled = false;
            resetDefaultsButton.disabled = true;

            // Disable all parameter-changing controls during simulation, except a few
            document.querySelectorAll('.controls input[type="range"], .controls select, .controls input[type="checkbox"]').forEach(el => {
                if (el.id !== 'showEnergy' && el.id !== 'autoScaleYAxisCheckbox' && el.id !== 'stopButton') {
                    el.disabled = true;
                }
            });
            showEnergyCheckbox.disabled = false; // Ensure these are explicitly enabled
            autoScaleYAxisCheckbox.disabled = false;

            simulationInterval = setInterval(go, 60); // Slightly faster interval
        }
        function stopSimulation() { 
            simulationRunning = false; clearInterval(simulationInterval);
            goContinuousButton.textContent = "é€£çºŒåŸ·è¡Œ";
            /* setupButton removed */ stopButton.disabled = true; resetDefaultsButton.disabled = false;

            // Re-enable controls: master checkboxes first, then let updateControlVisibility handle groups.
            selectUnlimitedGrassCheckbox.disabled = false;
            selectLimitedGrassCheckbox.disabled = false;
            selectSheepCheckbox.disabled = false;
            selectRabbitCheckbox.disabled = false;
            selectWolfCheckbox.disabled = false;
            
            updateControlVisibility(); // Re-enables/disables sliders within groups based on checkboxes

            // Manually re-enable general controls
            maxHerbivoresSlider.disabled = false;
            showEnergyCheckbox.disabled = false;
            autoScaleYAxisCheckbox.disabled = false;
            baseEnergyCostSlider.disabled = false; // ç¢ºä¿åŸºç¤è€—èƒ½æ»‘æ¡¿è¢«é‡æ–°å•Ÿç”¨
            reproductionEnergyCostFactorSlider.disabled = false; // ç¢ºä¿ç¹æ®–èƒ½é‡æˆæœ¬æ»‘æ¡¿è¢«é‡æ–°å•Ÿç”¨

            if (patches.length > 0) { 
                goContinuousButton.disabled = false; goOnceButton.disabled = false;

                // Capture final counts BEFORE any config/slider changes that might trigger repopulation prematurely
                const finalSheepCount = sheep.length;
                const finalRabbitCount = rabbits.length;
                const finalWolfCount = wolves.length; // This will be 0 if all wolves died
                const finalGrassPercent = (worldWidth > 0 && worldHeight > 0) ? Math.round((calculateCurrentGrassCount() / (worldWidth * worldHeight)) * 100) : 0;

                // Update config object directly with these final counts
                config.initialNumberSheep = finalSheepCount;
                config.initialNumberRabbits = finalRabbitCount;
                config.initialNumberWolves = finalWolfCount; // config will now have the correct 0 if wolves died
                config.initialLimitedGrassPercent = finalGrassPercent;

                // Update sliders and their display values directly from the corrected config
                initialNumberSheepSlider.value = config.initialNumberSheep;
                document.getElementById('initialNumberSheepValue').textContent = config.initialNumberSheep;

                initialNumberRabbitsSlider.value = config.initialNumberRabbits;
                document.getElementById('initialNumberRabbitsValue').textContent = config.initialNumberRabbits;

                initialNumberWolvesSlider.value = config.initialNumberWolves; // Will be 0 if finalWolfCount was 0
                document.getElementById('initialNumberWolvesValue').textContent = config.initialNumberWolves; // Span will show 0

                initialLimitedGrassPercentSlider.value = config.initialLimitedGrassPercent;
                document.getElementById('initialLimitedGrassPercentValue').textContent = config.initialLimitedGrassPercent;

                // Now, call updateInitialAnimalPopulations ONCE to synchronize the animal arrays
                // and the visual world based on the now correct and consistent config.
                updateInitialAnimalPopulations(); // This will use the correct config values.
            } else { 
                goContinuousButton.disabled = true; goOnceButton.disabled = true; 
            }
        }
        function enableButtonsAfterSetup() { goOnceButton.disabled = false; goContinuousButton.disabled = false; }
        function disableButtonsBeforeSetup() { goOnceButton.disabled = true; goContinuousButton.disabled = true; stopButton.disabled = true; }


        goOnceButton.addEventListener('click', go);
        goContinuousButton.addEventListener('click', startSimulation);
        stopButton.addEventListener('click', stopSimulation);
        resetDefaultsButton.addEventListener('click', resetToDefaults);
        
        showPopulationChartButton.addEventListener('click', () => {
            if (currentVisibleChart === 'population') return;
            currentVisibleChart = 'population';
            populationChartCanvasElement.style.display = 'block';
            energyPyramidCanvasElement.style.display = 'none';
            showPopulationChartButton.classList.add('active');
            showEnergyPyramidButton.classList.remove('active');

            // Ensure population chart is initialized and up-to-date
            if (!populationChartInstance) {
                initPopulationChart(); // This will use current chartData
            } else {
                // Resync data, as it might be stale if simulation ran while hidden
                populationChartInstance.data.labels = chartData.labels;
                populationChartInstance.data.datasets[0].data = chartData.grass;
                populationChartInstance.data.datasets[1].data = chartData.rabbits;
                populationChartInstance.data.datasets[2].data = chartData.sheep;
                populationChartInstance.data.datasets[3].data = chartData.wolves;
                populationChartInstance.update('none');
            }
        });

        showEnergyPyramidButton.addEventListener('click', () => {
            if (currentVisibleChart === 'energyPyramid') return;
            currentVisibleChart = 'energyPyramid';
            populationChartCanvasElement.style.display = 'none';
            energyPyramidCanvasElement.style.display = 'block';
            showEnergyPyramidButton.classList.add('active');
            showPopulationChartButton.classList.remove('active');

            if (!energyPyramidChartInstance) initEnergyPyramidChart();
            else updateEnergyPyramidChartData(); // Ensure it's current
        });

        window.onload = () => {
            // Initialize checkbox states from config
            selectUnlimitedGrassCheckbox.checked = config.hasUnlimitedGrass;
            selectLimitedGrassCheckbox.checked = config.hasLimitedGrass;
            selectSheepCheckbox.checked = config.hasSheep;
            selectRabbitCheckbox.checked = config.hasRabbit;
            selectWolfCheckbox.checked = config.hasWolf;
            showEnergyCheckbox.checked = config.showEnergy;
            autoScaleYAxisCheckbox.checked = config.autoScaleYAxis; // Initialize new checkbox
            // modelVersionSelect.value = config.modelVersion; // REMOVE THIS LINE

            // Initialize slider values in UI and config from default config
            document.querySelectorAll('input[type="range"]').forEach(slider => slider.dispatchEvent(new Event('input')));
            
            // Set initial canvas size based on CSS or explicit values
            // patchSize = simCanvasElement.width / worldWidth; 
            // (already done before setup() is called via the setup() function itself)
            
            disableButtonsBeforeSetup();
            setup(); 
            updateControlVisibility(); // Ensure controls are correctly shown/hidden on load

        };
    </script>
</body>
</html>