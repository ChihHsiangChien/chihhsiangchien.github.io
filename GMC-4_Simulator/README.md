# GMC-4 模擬器（擴充版）

## 說明

本專案以 Web Simulator 方式模擬 Gakken GMC-4 4-bit 微電腦，參考 `https://tsoj.manga.org/gakken/otona_gmc.html` 中的硬體規格與指令說明，並於瀏覽器中以 HTML/CSS/JavaScript 實現核心邏輯、UI 顯示與音效。

## 檔案結構

- `index.html`：主頁面，負責 UI 佈局與按鈕／LED 顯示。
- `main.js`：核心邏輯，包含記憶體分配、暫存器管理、指令解碼與執行流程、Web Audio API 音效，以及 UI 更新函式。
- `spec.html`：GMC-4 指令與操作規格文件，供對照與參考。
- `README.md`：本檔案（繁體中文）。

## 運行方式

1. 將本專案放置於可提供靜態檔案的目錄（或透過 Live Server、http-server 等工具）。
2. 瀏覽器開啓 `index.html` 即可啓動模擬器介面。

## 操作說明

- **7 段顯示螢幕**：顯示暫存器或資料值，以 16 進位表示。
- **7-bit Address LEDs**：以 7 顆 LED 顯示程式計數器 (PC) 二進位狀態。
- **2-pin LEDs**：顯示 CAL 指令作用後的狀態 (Y 暫存器指向的 LED) 或資料顯示。
- **Hex Keypad (0–F)**：輸入指令、立即值或地址用的 16 鈕十六進位按鍵。
- **A SET**：輸入兩位十六進位值後，設定地址指針 (addrPtr)。
- **INCR**：將當前輸入值 (`tempInput`) 寫入記憶體，並將地址指針自增。
- **RUN**：開始執行程式，從當前地址指針開始逐條讀取並執行指令。
- **預載程式**：按 RESET + 程式號碼 + RUN，可載入內建程式（需於 `builtins.js` 中配置機器碼）。
- **RESET**：Soft RESET 僅重置指針與暫存器，不影響記憶體內容，並將地址指針歸零。顯示器會顯示 `F`。
- **HARD RESET**：清除所有記憶體內容為 `F`，並重置指針與暫存器。顯示器會顯示 `F`。
- **程式記憶體預覽 (Program Memory)**：分為左右兩欄。左欄顯示程式記憶體 (0x00–0x4F) 的原始十六進位內容；右欄則顯示反組譯後的指令及助憶碼，提供更清晰的程式邏輯視圖。

## 核心功能

### 記憶體分佈
- `0x00`–`0x4F`：程式記憶體 (Program Memory)
- `0x50`–`0x5F`：資料記憶體 (Data Memory)
- `0x60`–`0x6F`：模擬用暫存器區 (A', B', Y', Z' 等)

### 暫存器
- `regA`, `regB`, `regY`：4-bit 暫存器對應 A/B/Y。
- `flag`：旗標位元 (Condition Flag)。
- `addrPtr`(`PC`)：程式指令指標 (Program Counter)。

### 4-bit 架構
GMC-4 被稱為 4-bit 微電腦，主要原因在於其 CPU 內部處理資料的基本單位是 4-bit。
- **暫存器寬度**：核心運算暫存器（如 A, Y 暫存器）均為 4-bit 寬。這意味著它們一次可以儲存 0 到 15 (0x0 到 0xF) 的值。
- **資料處理**：所有基本運算（加、減、比較等）都以 4-bit 為單位進行。若需處理更大數值，則需透過程式分多次操作。
- **十六進位表示**：由於 4-bit 恰好對應一個十六進位數字，因此 GMC-4 的輸入、顯示和記憶體內容都以十六進位表示，這也是其操作介面採用 0-F 十六進位按鍵的原因。


### 指令集支援狀況

| 指令              | 支援狀態 |
|------------------|:--------:|
| KA, AO          | 已實作   |
| CH, CY          | 尚未實作 |
| AM, MA, M+, M-  | 已實作   |
| TIA, AIA, TIY, AIY | 已實作   |
| CIA, CIY         | 已實作   |
| JUMP             | 已實作   |
| 延伸碼 (E0–EF)    | 部分實作 |

延伸碼 (CAL 系列) 實作支援：
- E0: CAL RSTO (清除 7 段顯示)
- E1: CAL SETR (點亮 2-pin LED)
- E2: CAL RSTR (熄滅 2-pin LED)
- E4: CAL CMPL (A 暫存器補數)
- E7: CAL ENDS (播放結束聲)
- E8: CAL ERRS (播放錯誤聲)
- E9: CAL SHTS (播放短 pi)
- EA: CAL LONS (播放長 pi-)
- EB: CAL SUND (播放音階)
- EC: CAL TIMR (延時)
- ED: CAL DSPR (顯示記憶體資料)
- EE: CAL DEM- (記憶體減法)
- EF: CAL DEM+ (記憶體加法)

尚未實作：E3 (保留)、E5 (CAL CHNG)、E6 (CAL SIFT)。

## 已知限制

- 部分指令 (CH、CY、CAL CHNG/CAL SIFT) 尚未完整實作，僅提供基本示範流程。
- 模擬器將記憶體初始化為全零 (硬體實際為 0xF)、鍵盤讀取 (KA 指令) 簡化為跳過等候。
- Soft RESET 僅重置指針與暫存器，不影響記憶體內容（對應實體 GMC-4 軟重置行為）。
- 已支援預載程式功能，請見下方「載入內建程式」範例，並可於 `builtins.js` 中配置程式機器碼。

## 範例程式

以下提供幾個基本示範，說明如何在模擬器中透過按鍵序列編寫程式，並觀察執行結果。

### 範例 1：寫入並驗證記憶體內容

**目標**：將數值 `A` 寫入程式記憶體位址 `10`，然後驗證該值是否已成功寫入。

**按鍵序列**：
```txt
HARD RESET  // (可選) 按下硬重置以清空所有記憶體
1 0 A SET   // 將位址指標 (PC) 設定到 0x10。螢幕會顯示 0 (目前內容)。
A INCR      // 將 A 寫入位址 0x10。Program View 會出現 "10: A"。PC 前進到 0x11，螢幕顯示 0 (位址 0x11 的內容)。
1 0 A SET   // 再次將位址指標設定到 0x10 以進行驗證。
```

**效果**：7 段顯示螢幕應顯示 `A`（十六進位），表示成功寫入並讀取資料。

### 範例 2：簡單無限迴圈顯示立即數

**目標**：在程式記憶體從 0 開始寫入以下指令，執行後持續在 7-seg 顯示固定值 3。

| 位址 | 指令    | 說明              |
|:----:|:--------|:------------------|
| 00   | 8 3     | TIA 3 → A         |
| 02   | 1       | AO → 顯示 A       |
| 03   | F 0 2   | JUMP 02 (loop)    |

**按鍵序列**：
```txt
RESET
8 INCR  // TIA [3]
3 INCR
1 INCR  // AO → 顯示 A
F INCR  // JUMP hi=0
0 INCR
2 INCR  // lo=2
RESET
1 RUN   // 執行程式（模式 1: RUN）
```

**效果**：7 段顯示螢幕會不斷顯示 `3`。

### 範例 3：設定 Y 暫存器並點亮對應 2-pin LED

**目標**：利用延伸碼 CAL SETR (E1) 將 2-pin LED #2 點亮。

| 位址 | 指令    | 說明                             |
|:----:|:--------|:---------------------------------|
| 00   | A 2     | TIY 2 → Y                        |
| 02   | E 1     | CAL SETR → 點亮 Y 指向的 LED     |

**按鍵序列**：
```txt
RESET
A INCR  // TIY [2]
2 INCR
E INCR  // 延伸碼 E
1 INCR  // CAL SETR (subcode=1)
RESET
1 RUN   // 執行程式
```

**效果**：2-pin LED 中的第 2 號（由 0 起算）會亮燈。

### 範例 4：載入內建程式

**目標**：按 RESET + 程式號碼 + RUN，載入 Organ 範例 (9)，並顯示程式記憶體。

**按鍵序列**：
```txt
RESET
9 RUN
```

**效果**：程式預覽區會顯示 Organ 範例程式碼，PC 歸零，可立即執行。