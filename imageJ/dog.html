<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>dog</title>
<link rel="stylesheet" href="styles.css">
<!-- KaTeX CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
</head>
<body>

<div id="toc">
<h2><a href="index.html">回到首頁</a></h2>
<div class="toc-container">
<div class="toc">
<ul>
<li><a href="#difference-of-gaussiandog">Difference of Gaussian（DoG）</a><ul>
<li><a href="#dog-spot">DoG 如何偵測 SPOT（亮點）？</a></li>
<li><a href="#_1">流程</a></li>
<li><a href="#spot">亮點（Spot）的偵測</a></li>
<li><a href="#spurious-spots">去除錯誤亮點（Spurious spots）</a></li>
<li><a href="#_2">優點</a></li>
<li><a href="#_3">使用時機</a></li>
</ul>
</li>
</ul>
</div>

</div>
</div>
<div id="content">
<h1 id="difference-of-gaussiandog">Difference of Gaussian（DoG）</h1>
<p>一種用來偵測亮點（spot）的常見方法，特別是在影像中物體呈現為圓形、亮、背景暗的情況下非常有效。</p>
<h2 id="dog-spot">DoG 如何偵測 SPOT（亮點）？</h2>
<p>DoG 是「Difference of Gaussian」的縮寫，即高斯差分，是用來近似 <a href="log.html">Laplacian of Gaussian</a>的一種方法，但比 LoG 更快、計算上更省資源。</p>
<h2 id="_1">流程</h2>
<ul>
<li>
<p>設定一個預期粒子直徑 d，根據圖像中粒子的外觀（例如細胞、點狀物）的大小手動設定。</p>
</li>
<li>
<p>計算兩個不同模糊程度的高斯標準差，使用下面的公式計算兩個高斯模糊的 σ（標準差）：這兩個 sigma 對應到不同的模糊程度：σ₁ 比較小，保留細節；σ₂ 比較大，模糊程度高。</p>
</li>
</ul>
<div class="arithmatex">\[
σ₁ =  \frac{1}{1 + \sqrt{2}}⋅𝑑  
\]</div>
<div class="arithmatex">\[
σ₂ =  \sqrt{2}⋅σ₁
\]</div>
<ul>
<li>進行高斯模糊與相減（DoG）
對原圖像各自套用 σ₁ 和 σ₂ 的高斯模糊。用 σ₁ 模糊結果減去 σ₂ 模糊結果，得到 DoG 圖像。這張圖會有清晰的局部極大值（local maxima），出現在亮點的中心位置。</li>
</ul>
<h2 id="spot">亮點（Spot）的偵測</h2>
<ol>
<li>
<p>尋找局部極大值（Local Maxima）對 DoG 圖像進行極大值搜尋，這些就是候選亮點。每個亮點會被指派一個「品質指標（quality）」，即 DoG 值的強度。</p>
</li>
<li>
<p>距離過近者去除，如果兩個亮點的距離小於 𝑑/2，則刪除品質較差的那一個。</p>
</li>
<li>
<p>進行次像素定位（Sub-pixel localization）使用拋物線內插法（parabolic interpolation），讓亮點的位置更精確。</p>
</li>
</ol>
<h2 id="spurious-spots">去除錯誤亮點（Spurious spots）</h2>
<ol>
<li>以 quality threshold 篩選。設定一個品質閾值，低於此閾值的亮點會被排除，只保留真正可信的亮點。</li>
</ol>
<h2 id="_2">優點</h2>
<ul>
<li>快速近似 LoG，但運算效能更好。</li>
<li>適合固定大小的亮點（即單一尺度）。</li>
<li>可處理 2D 和 3D 影像。</li>
</ul>
<h2 id="_3">使用時機</h2>
<ol>
<li>細胞核、粒線體、斑點蛋白等亮點分析</li>
<li>固定大小，且相對圓的結構</li>
<li>影像背景為暗，物件明亮者（高SNR）</li>
</ol>
<pre><code class="language-ijm">// ==== 使用者設定參數 ====
// 預期的粒子直徑 (像素)，這個值會用來推算兩個 Gaussian 模糊的程度
particle_diameter = 40;

// 設定 Find Maxima 的強度閾值，過濾掉太弱的亮點
quality_threshold = 10;


// ==== 推導參數 ====
// sigma1 與 sigma2 是 DoG (Difference of Gaussians) 所需的兩個不同 sigma
sigma1 = particle_diameter / (1 + sqrt(2));
sigma2 = sqrt(2) * sigma1;


// ==== 建立測試影像與反相處理 ====
// 產生 ImageJ 內建的 dot test image
run(&quot;Dot Blot&quot;);

// 將影像反相，讓亮點變成白點（方便找 maxima）
run(&quot;Invert&quot;);


// ==== 複製原始影像供後續處理 ====
// 備份目前影像為 &quot;Original&quot;
run(&quot;Duplicate...&quot;, &quot;title=Original&quot;);
rename(&quot;Original&quot;);


// ==== 對影像做第一次 Gaussian 模糊（sigma1）====
run(&quot;Duplicate...&quot;, &quot;title=Blur1&quot;);
run(&quot;Gaussian Blur...&quot;, &quot;sigma=&quot; + sigma1);


// ==== 對影像做第二次 Gaussian 模糊（sigma2）====
// 從原始影像再複製一次為 &quot;Blur2&quot;
selectWindow(&quot;Original&quot;);
run(&quot;Duplicate...&quot;, &quot;title=Blur2&quot;);
run(&quot;Gaussian Blur...&quot;, &quot;sigma=&quot; + sigma2);


// ==== 兩張模糊影像相減，產生 DoG ====
// 計算 Blur1 - Blur2，將結果命名為 DoG
imageCalculator(&quot;Subtract create&quot;, &quot;Blur1&quot;, &quot;Blur2&quot;);
rename(&quot;DoG&quot;);


// ==== 找出 DoG 圖中的亮點中心 ====
// 使用 Find Maxima 找出顯著的亮點位置
run(&quot;Find Maxima...&quot;, &quot;prominence=&quot;+ quality_threshold +&quot; output=[Point Selection]&quot;);


// ==== ROI manager ====
// 清空 ROI manager
roiManager(&quot;Reset&quot;);

// 把目前偵測到的亮點選區加到 ROI manager
roiManager(&quot;Add&quot;);


// ==== 在原始影像中顯示這些點選區 ====
// 切換回 &quot;Original&quot; 視窗
selectWindow(&quot;Original&quot;);

// 選擇剛剛儲存到 ROI manager
roiManager(&quot;Select&quot;, 0);


// ==== 清理中間影像====
// 關閉中介處理影像視窗
selectWindow(&quot;Blur1&quot;); close();
selectWindow(&quot;Blur2&quot;); close();
selectWindow(&quot;DoG&quot;); close();

</code></pre>
</div>

<!-- Mermaid JS -->
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({}); // Keep double braces for literal JS object
  mermaid.run({ nodes: document.querySelectorAll('.language-mermaid') }); // Keep double braces
</script>

<!-- KaTeX JS -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<!-- *** CORRECTED SCRIPT WITH ${...} ESCAPING *** -->
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$',  right: '$$',  display: true },
                        { left: '\\[', right: '\\]', display: true },
                        { left: '\\(', right: '\\)', display: false }
                    ],
                    ignoredTags: ['script','noscript','style','textarea','pre','code'],
                    throwOnError: false
                });
            });
        </script>

</body>
</html>
