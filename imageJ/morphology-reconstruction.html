<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>morphology-reconstruction</title>
<link rel="stylesheet" href="styles.css">
<!-- KaTeX CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
</head>
<body>

<div id="toc">
<h2><a href="index.html">回到首頁</a></h2>
<div class="toc-container">
<div class="toc">
<ul>
<li><a href="#_1">形態學重建</a><ul>
<li><a href="#_2">基本原理</a></li>
<li><a href="#_3">應用：優於傳統開/閉運算的濾波</a><ul>
<li><a href="#1-opening-by-reconstruction-">1. 重建式開運算 (Opening by Reconstruction) - 去除亮點</a></li>
<li><a href="#2-closing-by-reconstruction-">2. 重建式閉運算 (Closing by Reconstruction) - 填補暗點</a></li>
</ul>
</li>
<li><a href="#median-filter">與中值濾波器 (Median Filter) 的比較</a></li>
<li><a href="#_4">實作</a></li>
</ul>
</li>
</ul>
</div>

</div>
</div>
<div id="content">
<h1 id="_1">形態學重建</h1>
<p>形態學重建是基於形態學操作（膨脹、腐蝕），但能更精確地保留物件的原始形狀。其核心思想是使用一張「標記影像 (Marker Image)」在另一張「遮罩影像 (Mask Image)」的約束下，進行迭代式的膨脹或腐蝕，直到影像不再變化為止。</p>
<h2 id="_2">基本原理</h2>
<p>可以將灰階影像想像成一個三維的地形圖，像素的灰階值代表該點的高度。</p>
<ul>
<li><strong>遮罩影像 (Mask Image):</strong> 通常是我們的<strong>原始影像</strong>。它定義了重建過程的「地形邊界」，也就是像素值所能達到的上限（或下限）。</li>
<li><strong>標記影像 (Marker Image):</strong> 通常是原始影像經過簡單形態學處理（如腐蝕或膨脹）後的結果。它作為重建過程的「起始點」或「種子」。</li>
</ul>
<p>形態學重建有兩種基本操作：</p>
<ol>
<li>
<p><strong>膨脹式重建 (Reconstruction by Dilation):</strong></p>
<ul>
<li><strong>過程：</strong> 從「標記影像」開始，反覆進行膨脹操作。</li>
<li><strong>約束：</strong> 每一次膨脹的結果，其像素值都不能超過「遮罩影像」對應位置的像素值。</li>
<li><strong>比喻：</strong> 想像從標記影像的「山峰」開始注水，水會向周圍流動（膨脹），但水面高度永遠不能超過遮罩影像（原始地形）的高度。最終，所有能從標記點到達的區域都會被「淹沒」到與原始地形相同的高度。</li>
</ul>
</li>
<li>
<p><strong>腐蝕式重建 (Reconstruction by Erosion):</strong></p>
<ul>
<li><strong>過程：</strong> 從「標記影像」開始，反覆進行腐蝕操作。</li>
<li><strong>約束：</strong> 每一次腐蝕的結果，其像素值都不能低於「遮罩影像」對應位置的像素值。</li>
<li><strong>比喻：</strong> 想像將遮罩影像（原始地形）倒過來，然後從標記影像的位置開始向上「填充」，但填充物不能超出原始地形的邊界。</li>
</ul>
</li>
</ol>
<h2 id="_3">應用：優於傳統開/閉運算的濾波</h2>
<p>形態學重建最常見的應用是「重建式開運算」和「重建式閉運算」，用途是影像去噪，將亮點和暗點移除。</p>
<h3 id="1-opening-by-reconstruction-">1. 重建式開運算 (Opening by Reconstruction) - 去除亮點</h3>
<p>此操作能移除影像中的小型亮點（地形圖中的「小山峰」），同時完美保留較大物件的形狀和尺寸。</p>
<ul>
<li><strong>步驟：</strong><ol>
<li><strong>腐蝕 (Erosion):</strong> 對原始影像（遮罩）進行腐蝕，得到標記影像。這個步驟會壓平或移除所有小於結構元素的亮點（山峰）。</li>
<li><strong>膨脹式重建 (Reconstruction by Dilation):</strong> 使用腐蝕後的標記影像，在<strong>原始影像的約束</strong>下進行膨脹式重建。</li>
</ol>
</li>
<li><strong>結果：</strong> 原始影像中的主要結構會被完整「重建」回來，但那些在第一步被移除的小山峰則無法恢復，從而達到了去除亮點的效果。</li>
</ul>
<h3 id="2-closing-by-reconstruction-">2. 重建式閉運算 (Closing by Reconstruction) - 填補暗點</h3>
<p>此操作能填補影像中的小型暗點或孔洞（地形圖中的「小坑洞」），同時保留物件的形狀。</p>
<ul>
<li><strong>步驟：</strong><ol>
<li><strong>膨脹 (Dilation):</strong> 對原始影像（遮罩）進行膨脹，得到標記影像。這個步驟會填滿所有小於結構元素的暗點（坑洞）。</li>
<li><strong>腐蝕式重建 (Reconstruction by Erosion):</strong> 使用膨脹後的標記影像，在<strong>原始影像的約束</strong>下進行腐蝕式重建。</li>
</ol>
</li>
<li><strong>結果：</strong> 原始影像中的主要結構會被「重建」回來，但那些在第一步被填平的小坑洞則無法恢復，從而達到了填補暗點的效果。</li>
</ul>
<hr />
<h2 id="median-filter">與中值濾波器 (Median Filter) 的比較</h2>
<p>雖然形態學重建和中值濾波器（Median Filter）都可以用於影像去噪，但原理和適用情境有顯著差異：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">特性 (Feature)</th>
<th style="text-align: left;">形態學重建 (Morphological Reconstruction)</th>
<th style="text-align: left;">中值濾波器 (Median Filter)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>基本原理</strong></td>
<td style="text-align: left;">使用標記影像在遮罩影像的約束下進行迭代式膨脹/腐蝕。</td>
<td style="text-align: left;">將每個像素替換為其鄰域內像素灰階值的中位數。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>形狀保留</strong></td>
<td style="text-align: left;"><strong>極佳</strong>。能完美保留大於結構元素的物件輪廓與尺寸，不會造成收縮或變形。</td>
<td style="text-align: left;"><strong>良好</strong>，但較大半徑的濾波可能導致物件的尖角被鈍化、邊緣輕微變形。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>去噪機制</strong></td>
<td style="text-align: left;">移除尺寸小於結構元素的亮點（重建式開）或暗點（重建式閉）。</td>
<td style="text-align: left;">有效移除椒鹽式雜訊（Salt-and-pepper noise）等孤立的極端值像素。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>適用情境</strong></td>
<td style="text-align: left;">需要在不影響主要物件形狀的前提下，精確移除特定尺寸的雜訊或小物件。</td>
<td style="text-align: left;">快速去除隨機的亮暗點雜訊，且對邊緣的模糊效應比均值濾波小。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>缺點</strong></td>
<td style="text-align: left;">計算量較大，過程較複雜。</td>
<td style="text-align: left;">對於大片叢集的雜訊效果有限，且可能模糊細微的紋理。</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="_4">實作</h2>
<p>以下 Macro 腳本將演示如何使用形態學重建來移除 <code>Dot Blot</code> 範例影像中的亮點與暗點，並與中值濾波器 (Median Filter) 的結果進行比較。</p>
<pre><code class="language-ijm">run(&quot;Dot Blot&quot;);
run(&quot;Invert&quot;);
run(&quot;Duplicate...&quot;, &quot;title=origin&quot;);

/* 
 * 去除亮點
 * 對原始灰階影像進行一次腐蝕（Erosion）。腐蝕會將所有小的山峰消除或變淺，形成一個平滑的底圖。這個平滑後的影像就是你的標記影像。
 */
selectImage(&quot;origin&quot;);
run(&quot;Morphological Filters&quot;, &quot;operation=Erosion element=Square radius=2&quot;);
rename(&quot;erosion-marker&quot;);


/*
 * 執行膨脹式重建 (reconstructByDilation)，將腐蝕後的標記影像在原始影像的約束下進行膨脹。這個過程會把標記影像「膨脹」回原始影像的形狀，但那些在腐蝕階段被移除的亮點將無法恢復。
 */
run(&quot;Morphological Reconstruction&quot;, &quot;marker=erosion-marker mask=origin type=[By Dilation] connectivity=8&quot;);
rename(&quot;deLightResult&quot;);


/*
 * 移除暗點（Pepper Noise）
 * 暗點在灰階影像的地形圖中代表微小的「山谷」。膨脹式重建的「注水」原理正好可以用來填平這些小山谷。
 * 對原始灰階影像進行一次膨脹（Dilation）。膨脹會有效地小的「山峰」（包括亮點）擴大或與其他山峰合併，暗點填平，形成一個平滑的頂圖。這個平滑後的影像就是你的標記影像。
 */
selectImage(&quot;origin&quot;);
run(&quot;Morphological Filters&quot;, &quot;operation=Dilation element=Square radius=2&quot;);
rename(&quot;dilation-marker&quot;);

/*
 * 執行腐蝕式重建 (reconstructByErosion)，將膨脹後的標記影像在原始影像的約束下進行腐蝕。這個過程會把標記影像「腐蝕」回原始影像的形狀，但那些在膨脹階段被移除的亮點將無法恢復。
 */

run(&quot;Morphological Reconstruction&quot;, &quot;marker=dilation-marker mask=origin type=[By Erosion] connectivity=8&quot;);
rename(&quot;deDarkResult&quot;);



/*
 * 結合以上兩者操作，進行連續操作
 * 
*/


selectImage(&quot;origin&quot;);
run(&quot;Morphological Filters&quot;, &quot;operation=Erosion element=Square radius=2&quot;);
rename(&quot;erosion-marker&quot;);


run(&quot;Morphological Reconstruction&quot;, &quot;marker=erosion-marker mask=origin type=[By Dilation] connectivity=8&quot;);
rename(&quot;deLightResult&quot;);


selectImage(&quot;deLightResult&quot;);
run(&quot;Morphological Filters&quot;, &quot;operation=Dilation element=Square radius=2&quot;);
rename(&quot;dilation-marker&quot;);

run(&quot;Morphological Reconstruction&quot;, &quot;marker=dilation-marker mask=deLightResult type=[By Erosion] connectivity=8&quot;);
rename(&quot;result&quot;);

// 新增中值濾波器做比較
selectImage(&quot;origin&quot;);
run(&quot;Duplicate...&quot;, &quot;title=median-result&quot;);
run(&quot;Median...&quot;, &quot;radius=2&quot;);


// 觀察原始影像和兩種處理後影像的差異
imageCalculator(&quot;Subtract create 32-bit&quot;, &quot;origin&quot;,&quot;result&quot;);
selectImage(&quot;Result of origin&quot;);
rename(&quot;Diff-Reconstruction&quot;);
setMinAndMax(-100, 100);
run(&quot;3-3-2 RGB&quot;);

imageCalculator(&quot;Subtract create 32-bit&quot;, &quot;origin&quot;,&quot;median-result&quot;);
selectImage(&quot;Result of origin&quot;);
rename(&quot;Diff-Median&quot;);
setMinAndMax(-100, 100);
run(&quot;3-3-2 RGB&quot;);

run(&quot;Tile&quot;);

</code></pre>
</div>

<!-- Mermaid JS -->
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({}); // Keep double braces for literal JS object
  mermaid.run({ nodes: document.querySelectorAll('.language-mermaid') }); // Keep double braces
</script>

<!-- KaTeX JS -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"></script>
<!-- *** CORRECTED SCRIPT WITH ${...} ESCAPING *** -->
        <script>
            document.addEventListener("DOMContentLoaded", function() {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$',  right: '$$',  display: true },
                        { left: '\\[', right: '\\]', display: true },
                        { left: '\\(', right: '\\)', display: false }
                    ],
                    ignoredTags: ['script','noscript','style','textarea','pre','code'],
                    throwOnError: false
                });
            });
        </script>

</body>
</html>
