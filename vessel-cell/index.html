<!doctype html>
<html lang="zh-Hant">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Vessel pressure field</title>
	<style>
		body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "Microsoft JhengHei", sans-serif; padding: 12px; }
		canvas { image-rendering: pixelated; border: 1px solid #444; background: #000; }
		#controls { margin-bottom: 8px; }
	</style>
</head>
<body>
	<h2>Vessel skeleton → 16-bit pressure field</h2>
			<div id="controls">
				<label style="margin-left:0px">非線性 gamma: <input id="gamma" type="range" min="0.1" max="2" step="0.01" value="0.5"> <span id="gammaVal">0.50</span></label>
				<label style="margin-left:12px">模擬: 自動開始</label>
				<label style="margin-left:12px">速度: <input id="speed" type="range" min="0.1" max="5" step="0.1" value="1"> <span id="speedVal">1.0</span></label>
				<label style="margin-left:12px">質點數量: <input id="numParticles" type="number" min="1" max="200" value="10" style="width:64px"> <span id="numParticlesVal">10</span></label>
				<span id="info" style="margin-left:12px"></span>
			</div>
	<canvas id="canvas"></canvas>

	<script>
	// 需求核對
	// - 讀取 vessel-skeleton.csv（骨架二值化）
	// - 從左上角找到起點作為血管起點
	// - 使用 3x3 (8-connected) 鄰域尋找下一個點
	// - 起點壓力最高（16-bit，使用 65535），每找到新點壓力就 -1
	// - 在 index.html 中呈現壓力場

	const CSV_PATH = './vessel-skeleton.csv';
	const MAX_PRESSURE = 65535; // 16-bit max

			// auto-run on load
			document.addEventListener('DOMContentLoaded', () => {
				document.getElementById('info').textContent = '載入 CSV...';
				loadAndRender().catch(err => { document.getElementById('info').textContent = '錯誤: '+err; console.error(err); });
			});

			// show gamma value and re-render when changed
			const gammaEl = document.getElementById('gamma');
			const gammaValEl = document.getElementById('gammaVal');
			let lastRenderPressureBuffer = null; // store pressure buffer for quick re-render
			gammaEl.addEventListener('input', () => {
				gammaValEl.textContent = parseFloat(gammaEl.value).toFixed(2);
				// if we have already computed pressure, re-render using new gamma (use window.renderPressure if exposed)
				if(window._lastComputed && typeof window.renderPressure === 'function'){
					window.renderPressure(window._lastComputed.pressure, window._lastComputed.width, window._lastComputed.height);
				}
			});

	async function loadAndRender(){
		const txt = await fetch(CSV_PATH).then(r => { if(!r.ok) throw new Error('無法載入 CSV: '+r.status); return r.text(); });
		const lines = txt.trim().split(/\r?\n/).filter(l => l.length>0);
		const grid = lines.map(l => l.split(',').map(s => { const v = Number(s); return isNaN(v) ? 0 : v; }));
		const height = grid.length;
		const width = grid[0] ? grid[0].length : 0;
		if(width === 0 || height === 0) throw new Error('CSV 無有效大小');

		// skeleton binary map: treat >0 as skeleton
		const skeleton = new Uint8Array(width*height);
		for(let y=0; y < height; y++){
			const row = grid[y];
			for(let x=0;x<width;x++){
				skeleton[y*width + x] = (row[x] && row[x] > 0) ? 1 : 0;
			}
		}

		// find start: first skeleton pixel scanning from top-left
		let startIdx = -1;
		for(let y=0;y<height && startIdx===-1;y++){
			for(let x=0;x<width;x++){
				if(skeleton[y*width + x]){ startIdx = y*width + x; break; }
			}
		}
		if(startIdx === -1){ document.getElementById('info').textContent = '找不到骨架點'; return; }

		// pressure field (Uint16), visited map
		const pressure = new Uint16Array(width*height);
		const visited = new Uint8Array(width*height);

		// BFS (breadth-first) traversal using 8-connected neighbors (3x3)
		// Assign pressure by BFS layers: start has MAX_PRESSURE, each neighbor gets parent-1
		const dx = [-1,0,1,-1,1,-1,0,1];
		const dy = [-1,-1,-1,0,0,1,1,1];

		// queue-based BFS (avoid shift by using head index)
		const queue = new Uint32Array(width*height); // large enough buffer
		let qHead = 0, qTail = 0;
		visited[startIdx] = 1;
		pressure[startIdx] = MAX_PRESSURE;
		queue[qTail++] = startIdx;

		while(qHead < qTail){
			const cur = queue[qHead++];
			const cy = Math.floor(cur / width);
			const cx = cur % width;
			const curP = pressure[cur];
			for(let k=0;k<8;k++){
				const nx = cx + dx[k];
				const ny = cy + dy[k];
				if(nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
				const ni = ny*width + nx;
				if(skeleton[ni] && !visited[ni]){
					visited[ni] = 1;
					// 每找到新點壓力就 -1（BFS 保證第一次到達是最短路徑）
					pressure[ni] = Math.max(0, curP - 1);
					queue[qTail++] = ni;
				}
			}
		}

		// save pressure for possible re-render on gamma change
		// compute min/max among visited (already computed below), store them for normalization
		window._lastComputed = { pressure, width, height, startIdx, skeleton, visited };

		// render pressure field to canvas as colored map (higher pressure => warmer)
		const canvas = document.getElementById('canvas');
		canvas.width = width;
		canvas.height = height;
		// scale up for better viewing if small
		canvas.style.width = Math.min(800, width*4) + 'px';
		canvas.style.height = Math.min(800, height*4) + 'px';
		const ctx = canvas.getContext('2d');
			const img = ctx.createImageData(width, height);

			// helper: HSV -> RGB (h in [0,360], s,v in [0,1])
			function hsvToRgb(h, s, v){
				const c = v * s;
				const hh = (h / 60) % 6;
				const x = c * (1 - Math.abs(hh % 2 - 1));
				let r=0,g=0,b=0;
				if(hh >= 0 && hh < 1){ r=c; g=x; b=0; }
				else if(hh >= 1 && hh < 2){ r=x; g=c; b=0; }
				else if(hh >= 2 && hh < 3){ r=0; g=c; b=x; }
				else if(hh >= 3 && hh < 4){ r=0; g=x; b=c; }
				else if(hh >= 4 && hh < 5){ r=x; g=0; b=c; }
				else { r=c; g=0; b=x; }
				const m = v - c;
				return [ Math.round((r + m)*255), Math.round((g + m)*255), Math.round((b + m)*255) ];
			}

				// colormap: map normalized value t in [0,1] -> hue 240 (blue) -> 0 (red)
				// apply a gamma exponent for non-linear mapping: t_nl = t^gamma
								function pressureToColor(p){
										if(!p) return [0,0,0];
										// normalize using observed pmin/pmax if available (16-bit -> 0..1)
										let pmin = 0, pmax = MAX_PRESSURE;
										if(window._lastComputed && typeof window._lastComputed.pmin === 'number'){
											pmin = window._lastComputed.pmin;
											pmax = window._lastComputed.pmax;
										}
										let t0 = 0;
										if(pmax > pmin){ t0 = (p - pmin) / (pmax - pmin); }
										else { t0 = p / MAX_PRESSURE; }
										t0 = Math.max(0, Math.min(1, t0));
										const gammaInput = document.getElementById('gamma');
										let gamma = 1;
										if(gammaInput) gamma = parseFloat(gammaInput.value) || 1;
										const t = Math.pow(t0, gamma);
										const hue = (1 - t) * 240; // 240=blue, 0=red
										return hsvToRgb(hue, 1, 1);
								}

			for(let y=0;y<height;y++){
				for(let x=0;x<width;x++){
					const i = y*width + x;
					const p = pressure[i];
					const off = i*4;
					if(p === 0){
						// no pressure -> black
						img.data[off] = 0; img.data[off+1] = 0; img.data[off+2] = 0; img.data[off+3] = 255;
					} else {
						const [r,g,b] = pressureToColor(p);
						img.data[off] = r;
						img.data[off+1] = g;
						img.data[off+2] = b;
						img.data[off+3] = 255;
					}
				}
			}
				ctx.putImageData(img, 0, 0);
				// keep a copy of last ImageData (base map) for overlaying particle
				window._lastImageData = img;

				// small helper to allow re-rendering without recomputing pressure
						function renderPressure(pressureArr, width, height){
							const ctx = document.getElementById('canvas').getContext('2d');
							const img = ctx.createImageData(width, height);
						for(let y=0;y<height;y++){
							for(let x=0;x<width;x++){
								const i = y*width + x;
								const p = pressureArr[i];
								const off = i*4;
								if(p === 0){
									img.data[off] = 0; img.data[off+1] = 0; img.data[off+2] = 0; img.data[off+3] = 255;
								} else {
									const [r,g,b] = pressureToColor(p);
									img.data[off] = r;
									img.data[off+1] = g;
									img.data[off+2] = b;
									img.data[off+3] = 255;
								}
							}
						}
								ctx.putImageData(img, 0, 0);
								window._lastImageData = img;
								// redraw particles if exist
										if(window._particles && window._particles.length){
											for(const pt of window._particles) drawParticle(ctx, pt.x, pt.y);
										}
					}
								// expose for external calls
								window.renderPressure = renderPressure;

						// draw particle as a filled circle scaled to canvas display
						function drawParticle(ctx, px, py){
							// px,py are in pixel coordinates (image space)
							const scaleX = canvas.width / canvas.clientWidth;
							const scaleY = canvas.height / canvas.clientHeight;
							// because we set canvas.width/height to image pixels and scaled CSS, clientWidth is larger; instead draw in image space
							ctx.save();
							ctx.beginPath();
							ctx.fillStyle = 'rgba(255,0,0,0.9)';
							ctx.arc(px + 0.5, py + 0.5, 1.5, 0, Math.PI*2);
							ctx.fill();
							ctx.restore();
						}

						// initialize multiple particles at startIdx using UI-controlled count
						const numParticlesEl = document.getElementById('numParticles');
						const numParticlesVal = document.getElementById('numParticlesVal');
						function getNumParticles(){ return Math.max(1, Math.min(200, parseInt(numParticlesEl.value) || 10)); }
						numParticlesEl.addEventListener('input', ()=>{ numParticlesVal.textContent = getNumParticles(); adjustParticles(); });

						window._particles = [];
						function adjustParticles(){
							const target = getNumParticles();
							if(!window._lastComputed) return; // wait until computed
							const sy = Math.floor(startIdx / width);
							const sx = startIdx % width;
							// increase
							while(window._particles.length < target){
								window._particles.push({ x: sx, y: sy, prevIdx: undefined });
							}
							// decrease
							if(window._particles.length > target){
								window._particles.length = target;
							}
						}
						// set initial value
						numParticlesVal.textContent = getNumParticles();
						if(startIdx >= 0) adjustParticles();

						// particle simulation (auto-start)
						let animId = null;
						const speedEl = document.getElementById('speed');
						const speedVal = document.getElementById('speedVal');
						speedEl.addEventListener('input', ()=>{ speedVal.textContent = parseFloat(speedEl.value).toFixed(1); });

						function startSim(){
							if(animId) return;
							let lastTime = performance.now();
							function step(t){
								const dt = (t - lastTime)/1000; lastTime = t;
								updateParticles(dt * parseFloat(speedEl.value));
								animId = requestAnimationFrame(step);
							}
							animId = requestAnimationFrame(step);
						}

						// start immediately
						startSim();

						function stopSim(){ if(animId){ cancelAnimationFrame(animId); animId = null; } }

						// update multiple particles: each moves discretely on skeleton pixels
						function updateParticles(stepScale){
							if(!window._particles || !window._lastComputed) return;
							const width = window._lastComputed.width;
							const height = window._lastComputed.height;
							const skeleton = window._lastComputed.skeleton;
							const pressureArr = window._lastComputed.pressure;

							for(const p of window._particles){
								const cx = Math.round(p.x);
								const cy = Math.round(p.y);
								const ci = cy*width + cx;
								// gather skeleton neighbors
								const neigh = [];
								for(let oy=-1; oy<=1; oy++){
									for(let ox=-1; ox<=1; ox++){
										if(ox===0 && oy===0) continue;
										const nx = cx + ox;
										const ny = cy + oy;
										if(nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
										const ni = ny*width + nx;
										if(skeleton[ni]){
											neigh.push({x:nx,y:ny,idx:ni,p: pressureArr[ni] || 0});
										}
									}
								}
								if(neigh.length === 0) continue;

								const curP = pressureArr[ci] || 0;
								let candidates = neigh.filter(n => n.p < curP);
								if(candidates.length === 0) candidates = neigh.filter(n => n.p === curP);
								if(candidates.length === 0) candidates = neigh.slice();

								if(typeof p.prevIdx === 'number' && candidates.length > 1){
									const filtered = candidates.filter(c => c.idx !== p.prevIdx);
									if(filtered.length > 0) candidates = filtered;
								}

								let minP = Infinity;
								for(const c of candidates) minP = Math.min(minP, c.p);
								const opts = candidates.filter(c => c.p === minP);
								const choice = opts[Math.floor(Math.random() * opts.length)];

								p.prevIdx = ci;
								p.x = choice.x;
								p.y = choice.y;
							}

							// redraw base image and overlay all particles
							const ctx = document.getElementById('canvas').getContext('2d');
							if(window._lastImageData) ctx.putImageData(window._lastImageData, 0, 0);
							for(const p of window._particles) drawParticle(ctx, p.x, p.y);
						}

		// info
			const foundCount = visited.reduce((s,v)=>s+v,0);
				// compute min/max pressure among visited
				let pmax = 0, pmin = MAX_PRESSURE;
				for(let i=0;i<pressure.length;i++){
					if(visited[i]){
						pmax = Math.max(pmax, pressure[i]);
						pmin = Math.min(pmin, pressure[i]);
					}
				}
				// save pmin/pmax for normalization when rendering (16-bit -> 8-bit)
				window._lastComputed.pmin = pmin;
				window._lastComputed.pmax = pmax;
				document.getElementById('info').textContent = `size: ${width}×${height}, visited: ${foundCount}, pressure range: ${pmin}..${pmax}`;

			// draw start marker (small green square) so you can confirm the start
			if(typeof startIdx === 'number' && startIdx >= 0){
				const sy = Math.floor(startIdx / width);
				const sx = startIdx % width;
				const markerSize = 3;
				ctx.fillStyle = 'rgba(0,255,0,1)';
				ctx.fillRect(Math.max(0,sx-1), Math.max(0,sy-1), markerSize, markerSize);
			}
	}
	</script>
</body>
</html>

