<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Troxler 錯覺</title>
  <style>
    :root {
      --bg: #050505;
      --grid: #c21807;
      --peripheral: #ffd93d;
      --fixation: #00d27f;
      --text: #f5f5f5;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at 30% 20%, #0d0d0f, #050505 55%);
      color: var(--text);
      font-family: "Georgia", "Times New Roman", serif;
      display: flex;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
    }

    main {
      width: min(1240px, calc(100% - 24px));
      padding: 16px 0 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    h1 {
      margin: 0;
      letter-spacing: 0.03em;
      font-weight: 600;
      text-align: center;
    }

    p.lead {
      margin: 6px 0 4px;
      text-align: center;
      line-height: 1.6;
      max-width: 980px;
    }

    .stage {
      width: 100%;
      display: flex;
      gap: 16px;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
    }

    section.controls {
      min-width: 260px;
      max-width: 360px;
      flex: 1 1 320px;
      background: #0b0b0f;
      border: 1px solid #1f1f25;
      border-radius: 12px;
      padding: 14px 16px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px 18px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.28);
    }

    .control {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .control label {
      font-size: 15px;
    }

    .control input[type="color"] {
      width: 52px;
      height: 32px;
      padding: 0;
      border: none;
      background: transparent;
      cursor: pointer;
    }

    .slider {
      display: grid;
      grid-template-columns: 1fr 72px;
      gap: 10px;
      align-items: center;
    }

    .slider input[type="range"] {
      accent-color: #25c994;
      width: 100%;
    }

    .button-row {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      grid-column: 1 / -1;
    }

    button {
      padding: 9px 14px;
      border-radius: 10px;
      border: 1px solid #1f1f25;
      background: linear-gradient(135deg, #11131c, #0e121a);
      color: var(--text);
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.3);
    }

    .scene-wrap {
      flex: 1 1 520px;
      max-width: 820px;
      display: grid;
      grid-template-rows: auto auto;
      gap: 8px;
      justify-items: center;
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 16px;
      border: 1px solid #17171b;
      box-shadow: 0 16px 42px rgba(0, 0, 0, 0.35);
      background: var(--bg);
    }

    .tips {
      width: 100%;
      text-align: center;
      font-size: 14px;
      color: #cfd2ff;
      opacity: 0.9;
    }

    @media (max-width: 860px) {
      body {
        overflow: auto;
      }

      .stage {
        flex-direction: column;
        align-items: center;
      }

      main {
        width: calc(100% - 16px);
      }
    }
  </style>
</head>
<body>
  <main>
    <h1>Troxler 錯覺專注力實驗</h1>
    <p class="lead">周邊點不會真的淡出，錯覺源自視網膜適應。盯著中央綠點約 15 秒，自然感受周邊的消失感。</p>

    <div class="stage">
      <section class="controls">
        <div class="control">
          <label for="backgroundColor">背景</label>
          <input type="color" id="backgroundColor" value="#050505">
        </div>
        <div class="control">
          <label for="gridColor">交叉點</label>
          <input type="color" id="gridColor" value="#c21807">
        </div>
        <div class="control">
          <label for="peripheralColor">周邊點</label>
          <input type="color" id="peripheralColor" value="#ffd93d">
        </div>
        <div class="control">
          <label for="fixationColor">中央點</label>
          <input type="color" id="fixationColor" value="#00d27f">
        </div>

        <div class="slider">
          <div>
            <label for="speed">旋轉速度 (°/s)</label>
          </div>
          <div>
            <input type="range" id="speed" min="0" max="50" step="0.1" value="12">
            <div id="speedValue">12.0</div>
          </div>
        </div>

          <div class="slider">
            <div>
              <label for="dotSize">圓點尺寸</label>
            </div>
            <div>
              <input type="range" id="dotSize" min="0.4" max="1.6" step="0.02" value="0.5">
              <div id="dotSizeValue">0.5</div>
            </div>
          </div>

        <div class="button-row">
          <button id="toggle">暫停</button>
          <button id="reset">重設參數</button>
        </div>
      </section>

      <div class="scene-wrap">
        <canvas id="scene" width="720" height="640" aria-label="Troxler 錯覺畫布"></canvas>
        <div class="tips">建議全螢幕並減少直射光線，觀察周邊自然淡出的錯覺。</div>
      </div>
    </div>
  </main>

  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');

    const state = {
      bgColor: '#050505',
      gridColor: '#c21807',
      peripheralColor: '#ffd93d',
      fixationColor: '#00d27f',
      rotationSpeed: 12,
      paused: false,
      angle: Math.PI / 10,
      dotScale: 0.5
    };

    const controls = {
      backgroundColor: document.getElementById('backgroundColor'),
      gridColor: document.getElementById('gridColor'),
      peripheralColor: document.getElementById('peripheralColor'),
      fixationColor: document.getElementById('fixationColor'),
      speed: document.getElementById('speed'),
      speedValue: document.getElementById('speedValue'),
      dotSize: document.getElementById('dotSize'),
      dotSizeValue: document.getElementById('dotSizeValue'),
      toggle: document.getElementById('toggle'),
      reset: document.getElementById('reset')
    };

    function hexToRgba(hex, alpha = 1) {
      const value = hex.replace('#', '');
      const int = parseInt(value, 16);
      const r = (int >> 16) & 255;
      const g = (int >> 8) & 255;
      const b = int & 255;
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function resizeCanvas() {
      const maxHeight = Math.max(420, window.innerHeight - 220);
      const maxWidth = Math.min(window.innerWidth * 0.55, 820);
      const width = Math.max(520, Math.min(maxWidth, maxHeight * 0.95));
      const height = Math.max(460, Math.min(maxHeight, width * 0.95));
      canvas.width = Math.round(width);
      canvas.height = Math.round(height);
    }

    function drawCross(x, y, size, color, lineWidth) {
      ctx.save();
      ctx.translate(x, y);
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.moveTo(-size, 0);
      ctx.lineTo(size, 0);
      ctx.moveTo(0, -size);
      ctx.lineTo(0, size);
      ctx.stroke();
      ctx.restore();
    }

    function drawDot(x, y, radius, color) {
      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    function render() {
      ctx.fillStyle = state.bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const size = Math.min(canvas.width, canvas.height);
      const spacing = size * 0.12;
      const crossSize = spacing * 0.35;
      const lineWidth = Math.max(1.6, spacing * 0.08);

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(state.angle);
      ctx.shadowColor = hexToRgba(state.gridColor, 0.25);
      ctx.shadowBlur = 6;

      const reach = spacing * 3.5;
      for (let y = -reach; y <= reach; y += spacing) {
        for (let x = -reach; x <= reach; x += spacing) {
          drawCross(x, y, crossSize, state.gridColor, lineWidth);
        }
      }
      ctx.restore();

      const dotRadius = size * 0.035 * state.dotScale;
      const ring = size * 0.26;
      const peripheralColor = state.peripheralColor;

      drawDot(cx, cy - ring, dotRadius, peripheralColor);
      drawDot(cx - ring * 0.92, cy + ring * 0.78, dotRadius, peripheralColor);
      drawDot(cx + ring * 0.92, cy + ring * 0.78, dotRadius, peripheralColor);

      drawDot(cx, cy, dotRadius * 1.05, state.fixationColor);
    }

    function loop(timestamp) {
      if (!loop.last) loop.last = timestamp;
      const dt = (timestamp - loop.last) / 1000;
      loop.last = timestamp;

      if (!state.paused) {
        state.angle += (state.rotationSpeed * Math.PI / 180) * dt;
      }

      render();
      requestAnimationFrame(loop);
    }

    function syncControls() {
      controls.speedValue.textContent = state.rotationSpeed.toFixed(1);
      controls.dotSizeValue.textContent = state.dotScale.toFixed(2);
      document.documentElement.style.setProperty('--bg', state.bgColor);
      document.documentElement.style.setProperty('--grid', state.gridColor);
      document.documentElement.style.setProperty('--peripheral', state.peripheralColor);
      document.documentElement.style.setProperty('--fixation', state.fixationColor);
    }

    function bindEvents() {
      controls.backgroundColor.addEventListener('input', (e) => {
        state.bgColor = e.target.value;
        syncControls();
      });
      controls.gridColor.addEventListener('input', (e) => {
        state.gridColor = e.target.value;
        syncControls();
      });
      controls.peripheralColor.addEventListener('input', (e) => {
        state.peripheralColor = e.target.value;
        syncControls();
      });
      controls.fixationColor.addEventListener('input', (e) => {
        state.fixationColor = e.target.value;
        syncControls();
      });

      controls.speed.addEventListener('input', (e) => {
        state.rotationSpeed = parseFloat(e.target.value);
        controls.speedValue.textContent = state.rotationSpeed.toFixed(1);
      });

      controls.dotSize.addEventListener('input', (e) => {
        state.dotScale = parseFloat(e.target.value);
        controls.dotSizeValue.textContent = state.dotScale.toFixed(2);
      });

      controls.toggle.addEventListener('click', () => {
        state.paused = !state.paused;
        controls.toggle.textContent = state.paused ? '繼續' : '暫停';
      });

      controls.reset.addEventListener('click', () => {
        Object.assign(state, {
          bgColor: '#050505',
          gridColor: '#c21807',
          peripheralColor: '#ffd93d',
          fixationColor: '#00d27f',
          rotationSpeed: 12,
          dotScale: 0.5,
          paused: false,
          angle: Math.PI / 10
        });

        controls.backgroundColor.value = state.bgColor;
        controls.gridColor.value = state.gridColor;
        controls.peripheralColor.value = state.peripheralColor;
        controls.fixationColor.value = state.fixationColor;
        controls.speed.value = state.rotationSpeed;
        controls.dotSize.value = state.dotScale;
        controls.toggle.textContent = '暫停';
        syncControls();
      });

      window.addEventListener('resize', () => {
        resizeCanvas();
      });
    }

    resizeCanvas();
    bindEvents();
    syncControls();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
