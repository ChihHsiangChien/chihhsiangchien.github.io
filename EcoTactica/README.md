# 國家的決策 - JSON 旗標設計指南

本文件旨在說明如何在遊戲的 JSON 資料檔案（事件 `events` 和策略 `strategies`）中設計和使用旗標 (`flag`)，以控制遊戲元素的出現與消失邏輯。

## 旗標的核心概念

旗標是遊戲中的一種狀態標記，用於：
*   決定一個事件（event）是否應該觸發。
*   決定一個策略（strategy）是否可供玩家選擇。
*   讓事件或策略對遊戲狀態產生持久性影響。
*   控制事件的自動消失條件。

旗標的狀態儲存在 `gameState.flags` 物件中，其值通常為布林 (`true`/`false`)。

## JSON 中的旗標相關欄位

以下是在事件和策略定義中與旗標相關的主要欄位：

### 1. `required_flag`

*   **用途**：定義事件觸發或策略出現所 **必須滿足** 的旗標條件。
*   **規則**：
    *   如果此欄位不存在、為 `null` 或空陣列 `[]`，則視為條件已滿足。
    *   **字串 (String)**：例如 `"flag_A"`。表示 `flag_A` 必須為 `true`。
    *   **陣列 (Array of Strings)**：例如 `["flag_A", "flag_B"]`。表示所有列出的旗標（`flag_A` AND `flag_B`）都必須為 `true`。
    *   **物件 (Object)**：允許更複雜的邏輯組合：
        *   `{"and": ["flag_A", "flag_B"]}`：所有旗標都必須為 `true`。
        *   `{"or": ["flag_A", "flag_B"]}`：至少一個旗標為 `true`。
        *   `{"nand": ["flag_A", "flag_B"]}`：並非所有旗標都為 `true` (即至少一個為 `false`)。空陣列為 `false`。
        *   `{"nor": ["flag_A", "flag_B"]}`：所有旗標都必須為 `false`。空陣列為 `true`。
        *   `{"xor": ["flag_A", "flag_B"]}`：有奇數個旗標為 `true`。空陣列為 `false`。
        *   `{"xnor": ["flag_A", "flag_B"]}`：有偶數個旗標為 `true`。空陣列為 `true`。
*   **範例** (策略)：
    ```json
    {
        "id": "進階策略A",
        "required_flag": "基礎建設完成" 
    }
    ```
    ```json
    {
        "id": "進階策略B",
        "required_flag": { "and": ["科技突破", "資金到位"] }
    }
    ```

### 2. `prohibit_flag`

*   **用途**：定義事件觸發或策略出現所 **不能滿足** 的旗標條件。如果滿足此條件，則事件不觸發，策略不出現。
*   **規則**：
    *   如果此欄位不存在、為 `null` 或空陣列 `[]`，則視為條件未滿足（即不禁止）。
    *   **字串 (String)**：例如 `"flag_C"`。如果 `flag_C` 為 `true`，則禁止。
    *   **陣列 (Array of Strings)**：例如 `["flag_C", "flag_D"]`。如果列出的任一旗標（`flag_C` OR `flag_D`）為 `true`，則禁止。
    *   **物件 (Object)**：與 `required_flag` 的物件邏輯類似，但結果用於判斷是否禁止。
        *   `{"or": ["flag_X", "flag_Y"]}`：如果 `flag_X` 或 `flag_Y` 為 `true`，則禁止。
*   **範例** (策略)：
    ```json
    {
        "id": "一次性策略X",
        "set_flag": ["策略X已執行"],
        "prohibit_flag": "策略X已執行" // 確保此策略執行後不再出現
    }
    ```

### 3. `set_flag`

*   **用途**：定義當事件被確認或策略被執行後，需要 **設定 (設為 `true`)** 的旗標。
*   **格式**：一個包含旗標名稱字串的陣列。例如 `["flag_E", "flag_F"]`。
*   **範例** (策略)：
    ```json
    {
        "id": "啟動計畫",
        "set_flag": ["計畫已啟動", "新階段開始"]
    }
    ```

### 4. `clear_flag`

*   **用途**：定義當事件被確認或策略被執行後，需要 **清除 (刪除或設為 `false`)** 的旗標。
*   **格式**：一個包含旗標名稱字串的陣列。例如 `["flag_G"]`。
*   **範例** (策略)：
    ```json
    {
        "id": "解決危機",
        "clear_flag": ["危機狀態"]
    }
    ```

### 5. `disappears_if_flag_set` (僅限事件)

*   **用途**：定義事件卡片在顯示後，如果滿足特定旗標條件，則會自動從畫面上消失。
*   **規則**：與 `required_flag` 的判斷邏輯相同。如果條件滿足，事件消失。
*   **範例** (事件)：
    ```json
    {
        "id": "某個持續性問題",
        "set_flag": ["問題正在發生"], // 事件發生時設定的旗標
        "disappears_if_flag_set": "問題已解決" // 當 "問題已解決" 旗標被其他策略設定後，此事件消失
    }
    ```

## 設計原則與建議

1.  **鏈式設計**：透過 `set_flag` 和 `required_flag`，可以設計出一連串相互依賴的事件和策略，引導遊戲進程。例如，策略A設定旗標X，而策略B需要旗標X才能出現。
2.  **一次性項目**：對於只應執行一次的策略或只應觸發一次的事件，可以使用 `set_flag` 設定一個標記自身已發生的旗標，並在 `prohibit_flag` 中使用該旗標來阻止其再次出現。
    *   例如，`leopard_cat_crisis.json` 中的 `"推廣石虎保育教育"` 策略，它會 `set_flag: ["民眾石虎保育意識提升"]`，同時也有 `prohibit_flag: ["民眾石虎保育意識提升"]`。
3.  **避免死循環或無法達成的條件**：仔細檢查旗標的設定與需求，確保不會出現因為旗標條件永遠無法滿足而導致某些重要內容無法觸發的情況。
4.  **清晰命名**：給旗標取一個清晰、易於理解的名稱，方便追蹤和除錯。
5.  **模組化**：將相關聯的事件和策略（以及它們的旗標）組織在同一個 JSON 模組檔案中，有助於管理。
6.  **測試**：在設計完旗標邏輯後，務必在遊戲中進行充分測試，確保它們按預期工作。可以利用瀏覽器的開發者工具 `console.log(gameState.flags)` 來查看當前的旗標狀態。

遵循以上規則和建議，可以有效地利用旗標系統來打造豐富和動態的遊戲體驗。