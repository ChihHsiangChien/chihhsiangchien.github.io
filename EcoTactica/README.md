# 國家的決策 - JSON 旗標設計指南

本文件旨在說明如何在遊戲的 JSON 資料檔案（事件 `events` 和策略 `strategies`）中設計和使用旗標 (`flag`)，以控制遊戲元素的出現與消失邏輯。

## 旗標的核心概念

旗標是遊戲中的一種狀態標記，用於：
*   決定一個事件（event）是否應該觸發。
*   決定一個策略（strategy）是否可供玩家選擇。
*   讓事件或策略對遊戲狀態產生持久性影響。
*   控制事件的自動消失條件。

旗標的狀態儲存在 `gameState.flags` 物件中，其值通常為布林 (`true`/`false`)。

## JSON 中的旗標相關欄位

以下是在事件和策略定義中與旗標相關的主要欄位：

### 1. `required_flag`

*   **用途**：定義事件觸發或策略出現所 **必須滿足** 的旗標條件。
*   **規則**：
    *   如果此欄位不存在、為 `null` 或空陣列 `[]`，則視為條件已滿足。
    *   **字串 (String)**：例如 `"flag_A"`。表示 `flag_A` 必須為 `true`。
    *   **陣列 (Array of Strings)**：例如 `["flag_A", "flag_B"]`。表示所有列出的旗標（`flag_A` AND `flag_B`）都必須為 `true`。
    *   **物件 (Object)**：允許更複雜的邏輯組合：
        *   `{"and": ["flag_A", "flag_B"]}`：所有旗標都必須為 `true`。
        *   `{"or": ["flag_A", "flag_B"]}`：至少一個旗標為 `true`。
        *   `{"nand": ["flag_A", "flag_B"]}`：並非所有旗標都為 `true` (即至少一個為 `false`)。空陣列為 `false`。
        *   `{"nor": ["flag_A", "flag_B"]}`：所有旗標都必須為 `false`。空陣列為 `true`。
        *   `{"xor": ["flag_A", "flag_B"]}`：有奇數個旗標為 `true`。空陣列為 `false`。
        *   `{"xnor": ["flag_A", "flag_B"]}`：有偶數個旗標為 `true`。空陣列為 `true`。
*   **範例** (策略)：
    ```json
    {
        "id": "進階策略A",
        "required_flag": "基礎建設完成" 
    }
    ```
    ```json
    {
        "id": "進階策略B",
        "required_flag": { "and": ["科技突破", "資金到位"] }
    }
    ```

### 2. `prohibit_flag`

*   **用途**：定義事件觸發或策略出現所 **不能滿足** 的旗標條件。如果滿足此條件，則事件不觸發，策略不出現。
*   **規則**：
    *   如果此欄位不存在、為 `null` 或空陣列 `[]`，則視為條件未滿足（即不禁止）。
    *   **字串 (String)**：例如 `"flag_C"`。如果 `flag_C` 為 `true`，則禁止。
    *   **陣列 (Array of Strings)**：例如 `["flag_C", "flag_D"]`。如果列出的任一旗標（`flag_C` OR `flag_D`）為 `true`，則禁止。
    *   **物件 (Object)**：與 `required_flag` 的物件邏輯類似，但結果用於判斷是否禁止。
        *   `{"or": ["flag_X", "flag_Y"]}`：如果 `flag_X` 或 `flag_Y` 為 `true`，則禁止。
*   **範例** (策略)：
    ```json
    {
        "id": "一次性策略X",
        "set_flag": ["策略X已執行"],
        "prohibit_flag": "策略X已執行" // 確保此策略執行後不再出現
    }
    ```

### 3. `set_flag`

*   **用途**：定義當事件被確認或策略被執行後，需要 **設定 (設為 `true`)** 的旗標。
*   **格式**：一個包含旗標名稱字串的陣列。例如 `["flag_E", "flag_F"]`。
*   **範例** (策略)：
    ```json
    {
        "id": "啟動計畫",
        "set_flag": ["計畫已啟動", "新階段開始"]
    }
    ```

### 4. `clear_flag`

*   **用途**：定義當事件被確認或策略被執行後，需要 **清除 (刪除或設為 `false`)** 的旗標。
*   **格式**：一個包含旗標名稱字串的陣列。例如 `["flag_G"]`。
*   **範例** (策略)：
    ```json
    {
        "id": "解決危機",
        "clear_flag": ["危機狀態"]
    }
    ```

### 5. `disappears_if_flag_set` (僅限事件)

*   **用途**：定義事件卡片在顯示後，如果滿足特定旗標條件，則會自動從畫面上消失。
*   **規則**：與 `required_flag` 的判斷邏輯相同。如果條件滿足，事件消失。
*   **範例** (事件)：
    ```json
    {
        "id": "某個持續性問題",
        "set_flag": ["問題正在發生"], // 事件發生時設定的旗標
        "disappears_if_flag_set": "問題已解決" // 當 "問題已解決" 旗標被其他策略設定後，此事件消失
    }
    ```

## 設計原則與建議

1.  **鏈式設計**：透過 `set_flag` 和 `required_flag`，可以設計出一連串相互依賴的事件和策略，引導遊戲進程。例如，策略A設定旗標X，而策略B需要旗標X才能出現。
2.  **一次性項目**：對於只應執行一次的策略或只應觸發一次的事件，可以使用 `set_flag` 設定一個標記自身已發生的旗標，並在 `prohibit_flag` 中使用該旗標來阻止其再次出現。
    *   例如，`leopard_cat_crisis.json` 中的 `"推廣石虎保育教育"` 策略，它會 `set_flag: ["民眾石虎保育意識提升"]`，同時也有 `prohibit_flag: ["民眾石虎保育意識提升"]`。
3.  **避免死循環或無法達成的條件**：仔細檢查旗標的設定與需求，確保不會出現因為旗標條件永遠無法滿足而導致某些重要內容無法觸發的情況。
4.  **清晰命名**：給旗標取一個清晰、易於理解的名稱，方便追蹤和除錯。
5.  **模組化與分層設計**：
    *   將相關聯的事件和策略（以及它們的旗標）組織在同一個 JSON 模組檔案中，有助於管理。
    *   在設計複雜的保育議題（如石虎保育、綠蠵龜保育）時，可以考慮採用分層的樹狀結構來組織策略：
        *   **通用前置層 (Layer 0 - 可能來自 `common_elements.json`)**: 依賴遊戲早期或通用策略設定的基礎旗標（例如「民眾保育總體意識提升」、「全國生態監測網絡建立」）。
        *   **初始應對層 (Layer 1 - 模組內部)**: 針對特定議題的初步應對策略，可能依賴 Layer 0 的旗標，或在該議題的危機事件發生後出現。它們會設定該議題初步的進展旗標。
        *   **針對性解決層 (Layer 2 - 模組內部)**: 依賴 Layer 1 的成果，專門解決該議題下的特定子問題（如路殺、盜獵、棲地破碎），並設定更具體的解決方案旗標。這些策略可以直接使對應的負面事件消失。
        *   **整合與恢復層 (Layer 3 - 模組內部)**: 最終的策略會整合 Layer 2 的各項成果，並可能依賴通用的「國際合作」等旗標，以達成該議題保育的總體目標（如「石虎族群恢復」），並清除初始的危機旗標。
    *   這種分層設計有助於控制策略的複雜度和出現時機，引導玩家逐步解決問題，同時也允許不同分支的策略可以並行發展。
6.  **測試**：在設計完旗標邏輯後，務必在遊戲中進行充分測試，確保它們按預期工作。可以利用瀏覽器的開發者工具 `console.log(gameState.flags)` 來查看當前的旗標狀態。

遵循以上規則和建議，可以有效地利用旗標系統來打造豐富和動態的遊戲體驗。