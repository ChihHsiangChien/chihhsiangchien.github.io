<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>花的構造</title>
  <style>body { margin: 0; background-color: #aaaaaa; }</style>
</head>
<body>
<div id="controls-panel" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; color: white; z-index: 10;">
  <div>
    <label for="ovary-z-clip-slider">子房 Z軸 切面</label>
    <input type="range" id="ovary-z-clip-slider" min="-1" max="4" value="0" step="0.01" style="width: 200px;">
  </div>  
  <div style="margin-bottom: 10px;">
    <label for="ovule-z-clip-slider">珠被 Z軸 切面</label>
    <input type="range" id="ovule-z-clip-slider" min="-0.5" max="1.5" value="1.5" step="0.01" style="width: 200px;">
  </div>
  <div style="margin-top: 10px;">
    <label for="animation-slider">花粉管生長</label>
    <input type="range" id="animation-slider" min="0" max="1" value="0" step="0.01" style="width: 200px;">
  </div>
  <div style="margin-top: 10px;">
    <label for="integument-opacity-slider">珠被透明度</label>
    <input type="range" id="integument-opacity-slider" min="0" max="1" value="1" step="0.01" style="width: 200px;">
  </div>

  <button id="toggle-ovule-btn" style="width: 100%; margin-top: 10px; padding: 5px;">隱藏胚珠</button>
</div>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // === 顏色變數 ===
  const integumentColor = 0xffcc00; // 珠被、珠柄、反足細胞顏色

  // --- 建立裁切平面 ---
  const clipPlaneOvuleZ = new THREE.Plane(new THREE.Vector3(0, 0, -1), 1.5); // 用於胚珠
  const clipPlaneOvaryZ = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0);   // 用於子房

  // --- 建立可共用的材質 ---
  const innerIntegumentMaterial = new THREE.MeshStandardMaterial({
      color: integumentColor,
      transparent: false, // 預設不透明
      opacity: 1,
      side: THREE.DoubleSide,
      depthWrite: true, // 不透明物件應寫入深度
      clippingPlanes: [clipPlaneOvuleZ]
  });

  const outerIntegumentMaterial = new THREE.MeshStandardMaterial({
      color: integumentColor,
      transparent: false, // 預設不透明
      opacity: 1,
      side: THREE.DoubleSide,
      depthWrite: true, // 不透明物件應寫入深度
      clippingPlanes: [clipPlaneOvuleZ]
  });


  // === 建立細胞球體func ===
  function createCell(color = 0xffffcc, radius = 0.2) {
    const group = new THREE.Group();

    // 細胞本體（半透明）
    const cell = new THREE.Mesh(
      new THREE.SphereGeometry(radius, 16, 16),
      new THREE.MeshStandardMaterial({
        color,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide, // 关键：双面渲染
        depthWrite: false       // 防止深度冲突
      })
    );

    // 細胞核（不透明）
    const nucleus = new THREE.Mesh(
      new THREE.SphereGeometry(radius * 0.4, 16, 16),
      new THREE.MeshStandardMaterial({ 
        color: 0x333366,
        side: THREE.DoubleSide
     })
    );

    group.add(cell);
    group.add(nucleus);
    return group;
  }

  // === 建立胚囊 7 細胞 func===
  function createEmbryoSacGroup() {
    const sac = new THREE.Group();

    // 卵細胞
    const egg = createCell(0xff9999, 0.25);
    egg.position.set(0, -0.4, 0);
    sac.add(egg);

    // 助細胞（左右）
    const synergidL = createCell(0x99ccff);
    synergidL.position.set(-0.4, -0.4, 0);
    sac.add(synergidL);

    const synergidR = createCell(0x99ccff);
    synergidR.position.set(0.4, -0.4, 0);
    sac.add(synergidR);

    // 中央細胞（雙核）
    const central = new THREE.Group();
    const centralCell = new THREE.Mesh(
      new THREE.SphereGeometry(0.2, 16, 16),
      new THREE.MeshStandardMaterial({
        color: 0xccffcc,
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide  // 雙面

      })
    );
    centralCell.scale.set(1.5, 1, 1); // 拉伸以模擬中央細胞形狀
    central.add(centralCell);

    const nucleus1 = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 16, 16),
      new THREE.MeshStandardMaterial({ 
        color: 0x333366,
        side: THREE.DoubleSide
     })
    );
    nucleus1.position.set(-0.1, 0, 0);
    const nucleus2 = nucleus1.clone();
    nucleus2.position.set(0.1, 0, 0);
    central.add(nucleus1, nucleus2);

    central.position.set(0, 0.1, 0);
    sac.add(central);

    // 反足細胞（三個在頂部）
    for (let i = 0; i < 3; i++) {
      const anti = createCell(integumentColor, 0.18);
      anti.position.set((i - 1) * 0.3, 0.6, 0);
      sac.add(anti);
    }

    // 胚囊外殼
    const sacShell = new THREE.Mesh(
      new THREE.SphereGeometry(0.7, 32, 32),
      new THREE.MeshStandardMaterial({
        color: 0xAA9966,
        side: THREE.DoubleSide,
        transparent: true, // 改為半透明
        opacity: 0.5,
        depthWrite: false  // 不要寫入深度，避免遮擋問題
      })
    );
    sacShell.scale.set(1, 1.3, 1); // 拉伸以模擬胚囊形狀
    sac.add(sacShell);

    // --- 新增回傳資訊 ---
    // 計算 BBox 前先更新世界矩陣
    sac.updateMatrixWorld(true);
    const bbox = new THREE.Box3().setFromObject(sac);

    // 取得卵細胞座標 (世界座標，在此例中等於局部座標)
    const eggCellPosition = egg.position.clone();

    // 取得中央細胞核座標 (世界座標)
    const centralNucleiPositions = [
        nucleus1.getWorldPosition(new THREE.Vector3()),
        nucleus2.getWorldPosition(new THREE.Vector3())
    ];

    return { group: sac, bbox, eggCellPosition, centralNucleiPositions };
  }

  // 建立單一胚珠 func
  function createOvuleWithIntegument({ group: sac, bbox: sacBBox, eggCellPosition, centralNucleiPositions }) {
    const ovuleGroup = new THREE.Group();

    // 胚囊內部
    ovuleGroup.add(sac);

    // 根據胚囊大小計算珠被尺寸
    const sacSize = sacBBox.getSize(new THREE.Vector3());
    const baseInnerRadius = sacSize.x / 2 + 0.05; // 內珠被半徑比胚囊寬度稍大
    const scaleYInner = (sacSize.y / 2 + 0.1) / baseInnerRadius; // 內珠被Y軸縮放

    // 內層珠被
    const innerGeometry = new THREE.SphereGeometry(baseInnerRadius, 32, 32, 0, Math.PI * 2, 0, Math.PI * 0.85);
    innerGeometry.scale(1, scaleYInner, 1); // 调整缩放以匹配胚囊形状
    const inner = new THREE.Mesh(
      innerGeometry, innerIntegumentMaterial
    );
    ovuleGroup.add(inner);

    // 外層珠被
    const baseOuterRadius = baseInnerRadius + 0.02;
    const scaleYOuter = scaleYInner + 0.1;
    const outerGeometry = new THREE.SphereGeometry(baseOuterRadius, 32, 32, 0, Math.PI * 2, 0, Math.PI * 0.8); // 開口比內層稍大
    outerGeometry.scale(1, scaleYOuter, 1); // 调整缩放
    const outer = new THREE.Mesh(
      outerGeometry, outerIntegumentMaterial
    );
    ovuleGroup.add(outer);

    // 珠柄 (Funiculus and Raphe)
    const ovuleTopY = baseOuterRadius * scaleYOuter; // 胚珠頂部 Y 座標
    const ovuleSideX = baseOuterRadius; // 胚珠側面 X 座標

    // 使用 CatmullRomCurve3 可以通過一系列的點來定義平滑曲線
    const curve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0, ovuleTopY - 0.1, 0),   // 起點 (合點)
      new THREE.Vector3(0, ovuleTopY * 1.1 , 0),
      new THREE.Vector3(ovuleSideX * 0.8, ovuleTopY * 0.9 , 0),
      new THREE.Vector3(ovuleSideX * 1.1, -ovuleTopY * 0.2, 0),
      new THREE.Vector3(0.1, -ovuleTopY-0.5, 0),
      new THREE.Vector3(0.0, -ovuleTopY-0.8, 0)
    ]);

    // 2. 根據曲線路徑建立管狀幾何體
    const stalkGeometry = new THREE.TubeGeometry(curve, 50, 0.2, 8, false); // 增加分段數讓曲線更平滑

    // 3. 建立 Mesh 並加入場景
    const stalk = new THREE.Mesh(stalkGeometry, new THREE.MeshStandardMaterial({
      color: integumentColor, // 珠柄顏色
      depthWrite: true,

    }));
    ovuleGroup.add(stalk);

    // 計算珠孔位置 (外層珠被開口處的局部座標)
    const micropyleLocalPosition = new THREE.Vector3(0, -baseOuterRadius * scaleYOuter, 0);
    // 更新 group 的世界矩陣，以確保 BBox 計算正確
    ovuleGroup.updateMatrixWorld(true);
    const ovuleGroupBBox = new THREE.Box3().setFromObject(ovuleGroup);

    return { 
      group: ovuleGroup, 
      micropylePosition: micropyleLocalPosition, 
      bbox: ovuleGroupBBox,
      eggCellPosition: eggCellPosition, // 將座標透傳出去
      centralNucleiPositions: centralNucleiPositions // 將座標透傳出去
    };
  }


  // === 建立子房 func ===  
  function createOvary() {
    const ovaryGroup = new THREE.Group();
    // 將尺寸參數化，方便管理與回傳
    const innerRadius = 1;
    const outerRadius = 1.05;
    const scaleY = 2;
    const scaleX = 1.5;
    const scaleZ = 1.5;

    // 建立內壁
    const innerGeometry = new THREE.SphereGeometry(innerRadius, 32, 32);
    const innerMaterial = new THREE.MeshStandardMaterial({
      color: 0x88cc88,
      side: THREE.DoubleSide,
      transparent: true,
      depthWrite: false, // 設為 false 以解決透明物體排序問題
      opacity: 0.5,
      clippingPlanes: [clipPlaneOvaryZ] // 將裁切平面應用於此材質
    });
    const innerMesh = new THREE.Mesh(innerGeometry, innerMaterial);
    innerMesh.scale.set(scaleX, scaleY, scaleZ); // 拉伸
    ovaryGroup.add(innerMesh);

    // 建立外壁 
    const outerGeometry = new THREE.SphereGeometry(outerRadius, 32, 32);
    const outerMaterial = new THREE.MeshStandardMaterial({
      color: 0x66aa66,
      side: THREE.DoubleSide,
      transparent: true,
      depthWrite: false, // 設為 false 以解決透明物體排序問題
      opacity: 0.5,
      clippingPlanes: [clipPlaneOvaryZ] // 將裁切平面應用於此材質
    });
    const outerMesh = new THREE.Mesh(outerGeometry, outerMaterial);
    outerMesh.scale.set(scaleX, scaleY, scaleZ); // 拉伸
    ovaryGroup.add(outerMesh);

    // 計算子房頂部 Y 座標 使用內壁
    const topY = innerRadius * scaleY;

    return { group: ovaryGroup, topY: topY };
  }

  // === 建立花柱與柱頭 func ===
  function createStyleAndStigma(ovaryTopY) {
    const group = new THREE.Group();
    const styleHeight = 3; // 花柱高度
    const styleRadius = 0.2; // 花柱半徑
    const stigmaRadius = 0.5; // 柱頭半徑
    const stigmaHeight = 0.2; // 柱頭高度

    // 花柱 (Style)
    const styleGeometry = new THREE.CylinderGeometry(styleRadius, styleRadius, styleHeight, 32);
    const styleMaterial = new THREE.MeshStandardMaterial({
      color: 0x99cc99, // 換個綠色系
      side: THREE.DoubleSide,
      transparent: true,
      depthWrite: false,
      opacity: 0.8,
      clippingPlanes: [clipPlaneOvaryZ] // 套用與子房相同的裁切
    });
    const styleMesh = new THREE.Mesh(styleGeometry, styleMaterial);
    // 將花柱放在子房頂部
    styleMesh.position.set(0, ovaryTopY + styleHeight / 2, 0);
    group.add(styleMesh);

    // 柱頭 (Stigma)
    const stigmaGeometry = new THREE.CylinderGeometry(stigmaRadius, stigmaRadius, stigmaHeight, 32);
    const stigmaMaterial = new THREE.MeshStandardMaterial({
        color: 0x77aa77, // 較深的綠色
        side: THREE.DoubleSide,
        roughness: 0.8,
        depthWrite: false,
        clippingPlanes: [clipPlaneOvaryZ] // 套用與子房相同的裁切
    });
    const stigmaMesh = new THREE.Mesh(stigmaGeometry, stigmaMaterial);
    // 將柱頭放在花柱頂部
    const stigmaCenterY = ovaryTopY + styleHeight + stigmaHeight / 2;
    stigmaMesh.position.set(0, stigmaCenterY, 0);
    group.add(stigmaMesh);

    // 計算柱頭頂部位置並回傳
    const stigmaTopY = stigmaCenterY + stigmaHeight / 2;
    const stigmaTopPosition = new THREE.Vector3(0, stigmaTopY, 0);

    return { group: group, stigmaTopPosition: stigmaTopPosition };
  }

  // === 建立花粉與花粉管 func ===
  function createPollenAndTube(stigmaTop, ovaryTop, micropyleTarget, ovuleBBox, sacBBox) {
      const group = new THREE.Group();

      // 1. 建立花粉粒
      const pollen = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0xffff00 })
      );
      pollen.position.copy(stigmaTop).y += 0.1; // 放在柱頭頂端稍上方
      group.add(pollen);

      // 2. 定義花粉管路徑，使其繞過胚珠的 BBox
      const ovuleCenter = ovuleBBox.getCenter(new THREE.Vector3());
      const ovuleSize = ovuleBBox.getSize(new THREE.Vector3());
      const ovuleHeight = ovuleSize.y;

      const avoidancePoint1 = new THREE.Vector3(
          ovuleBBox.min.x - 0.2, // 在 X 軸方向繞過
          ovuleCenter.y + ovuleHeight * 0.25, // 在胚珠中心點上方 1/4 高度的位置
          ovuleCenter.z // 保持與中心點相同的 Z 軸
      );

      const avoidancePoint2 = new THREE.Vector3(
          ovuleBBox.min.x - 0.2 , // 在 X 軸方向繞過
          ovuleCenter.y - ovuleHeight * 0.1,
          ovuleCenter.z // 保持與中心點相同的 Z 軸
      );

      const avoidancePoint3 = new THREE.Vector3(
          ovuleBBox.min.x-0.1 , // 在 X 軸方向繞過
          ovuleCenter.y - ovuleHeight * 0.2, // 在胚珠中心點上方 1/4 高度的位置
          ovuleCenter.z // 保持與中心點相同的 Z 軸
      );      

      const approachPoint = new THREE.Vector3(
          micropyleTarget.x -0.2,
          micropyleTarget.y -0.2, // 從 BBox 下方接近
          micropyleTarget.z
      );
      const sacCenter = sacBBox.getCenter(new THREE.Vector3());
      const sacBottom = new THREE.Vector3(
          sacCenter.x,
          sacBBox.min.y,
          sacCenter.z,
      );
      const pollenTubePath = new THREE.CatmullRomCurve3([
          pollen.position.clone(), // 起點：花粉粒
          new THREE.Vector3(0, stigmaTop.y * 0.5 + ovaryTop * 0.5, 0), // 中點：花柱中間
          new THREE.Vector3(0, ovaryTop, 0), // 中點：子房頂部
          avoidancePoint1,          // 繞到胚珠側面
          avoidancePoint2,          // 繞到胚珠側面          
          avoidancePoint3,          // 繞到胚珠側面                    
          approachPoint,           // 繞到珠孔下方
          micropyleTarget,         // 穿過珠孔
          sacBottom              // 終點
      ]);

      // 3. 建立花粉管 (先用空的 geometry)
      const tubeMaterial = new THREE.MeshStandardMaterial({
          color: 0xffddaa,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.5,
          depthWrite: false // 不寫入深度

      });
      const pollenTube = new THREE.Mesh(new THREE.BufferGeometry(), tubeMaterial);
      group.add(pollenTube);

      // 4. 建立管核與精細胞
      const tubeNucleusMaterial = new THREE.MeshStandardMaterial({ color: 0xff9900, emissive: 0x553300 });
      const tubeNucleus = new THREE.Mesh(new THREE.SphereGeometry(0.04*0.5, 8, 8), tubeNucleusMaterial);
      tubeNucleus.visible = false; // 預設隱藏
      group.add(tubeNucleus);

      // 使用 createCell 函式建立包含細胞核的精細胞
      const sperm1 = createCell(0x6666ff, 0.04); // 傳入顏色和半徑
      const sperm2 = createCell(0x6666ff, 0.04);
      sperm1.visible = false; // 預設隱藏
      sperm2.visible = false; // 預設隱藏
      group.add(sperm1, sperm2);

      // 將所有需要動畫控制的物件回傳
      return { group, pollenTube, pollenTubePath, tubeNucleus, sperm1, sperm2 };
  }

  // === 初始化 Three.js ===
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xeeeeee);
  const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
  camera.position.set(0, 0, 8);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.localClippingEnabled = true; // *** 啟用局部裁切功能 ***
  document.body.appendChild(renderer.domElement);

  // === 光源 ===
  scene.add(new THREE.AmbientLight(0x888888));
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(3, 3, 3);
  scene.add(light);

  // === OrbitControls ===
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // === 建立胚囊 ===
  const sacData = createEmbryoSacGroup();
  const sacBBox = sacData.bbox; // 胚囊的 BBox

  // === 建立胚珠 (珠被、珠柄) ===
  const ovuleData = createOvuleWithIntegument(sacData); // 呼叫方式不變，依然簡潔
  const ovule = ovuleData.group;
  const micropylePosition = ovuleData.micropylePosition;
  const ovuleBBox = ovuleData.bbox; // 整個胚珠的 BBox
  const eggCellPosition = ovuleData.eggCellPosition;
  scene.add(ovule);

  // === 建立子房、花柱與柱頭 ===
  const ovaryData = createOvary();
  const ovary = ovaryData.group;
  const ovaryTopY = ovaryData.topY;
  scene.add(ovary);
 
  const styleAndStigmaData = createStyleAndStigma(ovaryTopY);
  const styleAndStigma = styleAndStigmaData.group;
  const stigmaTopPosition = styleAndStigmaData.stigmaTopPosition; 
  scene.add(styleAndStigma);
  
  // === 建立花粉與花粉管 ===
  const { 
    group: pollenGroup, 
    pollenTube, 
    pollenTubePath, 
    tubeNucleus, 
    sperm1, 
    sperm2 
  } = createPollenAndTube(stigmaTopPosition, ovaryTopY, micropylePosition, ovuleBBox, sacBBox);
  scene.add(pollenGroup);

  // === UI 控制器事件 ===
  const ovuleZClipSlider = document.getElementById('ovule-z-clip-slider');
  const ovaryZClipSlider = document.getElementById('ovary-z-clip-slider');
  const toggleOvuleBtn = document.getElementById('toggle-ovule-btn');
  const integumentOpacitySlider = document.getElementById('integument-opacity-slider');
  const animationSlider = document.getElementById('animation-slider');

  ovuleZClipSlider.addEventListener('input', (event) => {
    // 當滑桿移動時，更新胚珠裁切平面的位置
    clipPlaneOvuleZ.constant = parseFloat(event.target.value);
  });

  ovaryZClipSlider.addEventListener('input', (event) => {
    // 當滑桿移動時，更新子房裁切平面的位置
    clipPlaneOvaryZ.constant = parseFloat(event.target.value);
  });

  integumentOpacitySlider.addEventListener('input', (event) => {
    const opacity = parseFloat(event.target.value);
    const isTransparent = opacity < 1;

    // 同時更新內外珠被的材質屬性
    [innerIntegumentMaterial, outerIntegumentMaterial].forEach(material => {
        material.transparent = isTransparent;
        material.opacity = opacity;
        // 關鍵：只有在不透明時才寫入深度，以避免透明物件的排序問題
        material.depthWrite = !isTransparent; 
        material.needsUpdate = true; // 通知 Three.js 材質已更新
    });
  });

  toggleOvuleBtn.addEventListener('click', () => {
    ovule.visible = !ovule.visible;
    toggleOvuleBtn.textContent = ovule.visible ? '隱藏胚珠' : '顯示胚珠';
  });

  // === 畫面更新 ===
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();

    // --- 花粉管與細胞動畫 ---
    const progress = parseFloat(animationSlider.value);

    if (progress > 0.01) {
        const tubePoints = pollenTubePath.getPoints(200); // 增加路徑點的密度以提高精度
        const currentPointCount = Math.max(2, Math.ceil(progress * tubePoints.length));
        const currentPath = new THREE.CatmullRomCurve3(tubePoints.slice(0, currentPointCount));

        // 更新管狀幾何體
        if (pollenTube.geometry) pollenTube.geometry.dispose();
        pollenTube.geometry = new THREE.TubeGeometry(currentPath, currentPointCount, 0.05, 8, false);

        // 顯示細胞
        // The visibility of each cell will be determined by the logic below

        // 計算目前花粉管的總長度
        const currentLength = currentPath.getLength();

        // --- 更新管核與精細胞位置 ---
        const tubeNucleusOffset = 0.05; // 管核與管尖的距離
        const sperm1Offset = 0.15;      // 精細胞1與管尖的距離
        const sperm2Offset = 0.25;      // 精細胞2與管尖的距離

        // 只有當花粉管長度足夠時才顯示管核，並讓它與管尖保持一個小距離
        if (currentLength > tubeNucleusOffset) {
            const t_nucleus = 1 - (tubeNucleusOffset / currentLength);
            tubeNucleus.position.copy(currentPath.getPointAt(t_nucleus));
            tubeNucleus.visible = true;
        } else {
            tubeNucleus.visible = false;
        }

        // 只有當花粉管長度足夠時才顯示精細胞
        if (currentLength > sperm1Offset) {
            const t1 = 1 - (sperm1Offset / currentLength);
            sperm1.position.copy(currentPath.getPointAt(t1));
            sperm1.visible = true;
        } else {
            sperm1.visible = false;
        }
        if (currentLength > sperm2Offset) {
            const t2 = 1 - (sperm2Offset / currentLength);
            sperm2.position.copy(currentPath.getPointAt(t2));
            sperm2.visible = true;
        } else {
            sperm2.visible = false;
        }
    } else {
        // 如果進度為 0，清空 geometry 並隱藏所有細胞
        if (pollenTube.geometry) pollenTube.geometry.dispose();
        pollenTube.geometry = new THREE.BufferGeometry();
        tubeNucleus.visible = false;
        sperm1.visible = false;
        sperm2.visible = false;
    }

    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>