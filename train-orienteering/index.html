<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>一線九驛求解器 Orienteering </title>
  <style>
    body { font-family: Arial, sans-serif; margin: 24px; }
    fieldset { margin-bottom: 16px; }
    label { display: inline-block; width: 120px; margin-right: 8px; }
    input[type="text"], input[type="number"], select { width: 200px; }
    pre { background: #f5f5f5; padding: 12px; overflow-x: auto; }
    .row { margin: 6px 0; }
    button { padding: 6px 12px; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { border: 1px solid #ccc; padding: 4px 8px; border-radius: 4px; background: #fafafa; }
    .chip input { margin-right: 4px; }
  </style>
</head>
<body>
  <h2>一線九驛求解器</h2>
  <div style="margin-bottom:18px;color:#333;max-width:700px;line-height:1.7">
    本工具根據台鐵內灣線時刻表，幫你規劃在指定時段內，從起點出發、盡量多經過不同車站、最後回到終點的最佳搭車路線。你可以自訂必須造訪或排除的車站、每站停留時間等條件，系統會自動搜尋所有可行路徑，呈現最優解。<br>    
  </div>
  <fieldset>
    <legend>參數</legend>
    <div class="row">
      <label for="start">起點</label>
      <select id="start"></select>
    </div>
    <div class="row">
      <label for="end">終點</label>
      <select id="end"></select>
    </div>
    <div class="row">
      <label for="startTime">出發時間</label>
      <input id="startTime" type="time" value="07:00" />
    </div>
    <div class="row">
      <label for="endTime">截止時間</label>
      <input id="endTime" type="time" value="12:00" />
    </div>
    <div class="row">
      <label for="defaultDwell">每站至少停留 (分)</label>
      <input id="defaultDwell" type="number" min="0" value="10" />
    </div>
    <div class="row">
      <label>必須造訪</label>
      <div id="mustBox" class="chips"></div>
    </div>
    <div class="row" id="mustDwellRow" style="display:none; flex-direction:column; gap:4px; margin-left:128px; margin-top:4px;">
      <!-- 動態產生每個必訪站的停留時間輸入框 -->
    </div>
    <div class="row">
      <label>排除</label>
      <div id="excludeBox" class="chips"></div>
    </div>
    <button id="solveBtn">開始計算</button>
  </fieldset>
  <div id="status"></div>

  <pre id="output"></pre>
  <div id="routeGrid"></div>

  <script>
    const statusEl = document.getElementById('status');
    const outputEl = document.getElementById('output');
    const startSel = document.getElementById('start');
    const endSel = document.getElementById('end');
    const mustBox = document.getElementById('mustBox');
    const mustDwellRow = document.getElementById('mustDwellRow');
    const excludeBox = document.getElementById('excludeBox');

    let edgesByFrom = {};
    let stations = [];

    const parseHHMM = (s) => {
      const [h, m] = s.split(':').map(Number);
      return h * 60 + m;
    };

    const fmtHHMM = (t) => {
      const h = Math.floor(t / 60) % 24;
      const m = t % 60;
      return `${h}:${m.toString().padStart(2, '0')}`;
    };

    const fmtWait = (minutes) => (minutes >= 0 ? `stay ${minutes} min` : 'stay N/A');

    const pad = (name, width) => name.padEnd(width, ' ');

    async function loadData() {
      statusEl.textContent = 'Loading edges_from.json...';
      const res = await fetch('edges_from.json');
      if (!res.ok) throw new Error('Failed to load edges_from.json');
      const data = await res.json();
      buildEdges(data.edges);
      statusEl.textContent = 'Loaded';
    }

    function buildEdges(edges) {
      edgesByFrom = {};
      const stationSet = new Set();
      edges.forEach((e) => {
        const dep = e.dep?.trim();
        const arr = e.arr?.trim();
        if (!dep || !arr || !dep.includes(':') || !arr.includes(':')) return;
        const edge = {
          train: String(e.train),
          origin: e.from,
          dest: e.to,
          dep: parseHHMM(dep),
          arr: parseHHMM(arr),
          direction: e.direction || '',
        };
        stationSet.add(edge.origin);
        stationSet.add(edge.dest);
        if (!edgesByFrom[edge.origin]) edgesByFrom[edge.origin] = [];
        edgesByFrom[edge.origin].push(edge);
      });
      Object.values(edgesByFrom).forEach((lst) => lst.sort((a, b) => a.dep - b.dep));
      const desiredOrder = [
        '竹中', '上員', '榮華', '竹東', '橫山', '九讚頭', '合興', '富貴', '內灣',
      ];
      const setArr = Array.from(stationSet);
      const ordered = desiredOrder.filter((s) => stationSet.has(s));
      const remaining = setArr.filter((s) => !desiredOrder.includes(s));
      stations = ordered.concat(remaining.sort());
      populateStations();
    }

    function populateStations() {
      startSel.innerHTML = '';
      endSel.innerHTML = '';
      for (const s of stations) {
        const opt1 = document.createElement('option');
        opt1.value = opt1.textContent = s;
        startSel.appendChild(opt1);
        const opt2 = document.createElement('option');
        opt2.value = opt2.textContent = s;
        endSel.appendChild(opt2.cloneNode(true));
      }
      // Default end = start
      endSel.value = startSel.value;

      // Build checkboxes for must/exclude
      const buildChips = (box, name) => {
        box.innerHTML = '';
        for (const s of stations) {
          const label = document.createElement('label');
          label.className = 'chip';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = s;
          cb.name = name;
          label.appendChild(cb);
          label.appendChild(document.createTextNode(s));
          box.appendChild(label);
        }
      };
      buildChips(mustBox, 'must');
      buildChips(excludeBox, 'exclude');
      // 綁定必訪站勾選事件，動態顯示停留時間欄位
      mustBox.addEventListener('change', updateMustDwellInputs);
      updateMustDwellInputs();
    }

    function updateMustDwellInputs() {
      // 取得所有已勾選的必訪站
      const checked = Array.from(document.querySelectorAll('input[name="must"]:checked')).map(el => el.value);
      mustDwellRow.innerHTML = '';
      if (checked.length === 0) {
        mustDwellRow.style.display = 'none';
        return;
      }
      mustDwellRow.style.display = '';
      const defaultDwell = Number(document.getElementById('defaultDwell')?.value || 10);
      for (const s of checked) {
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        const label = document.createElement('label');
        label.textContent = `${s} 至少停留 (分)`;
        label.style.width = '100px';
        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.value = defaultDwell;
        input.style.width = '60px';
        input.className = 'must-dwell-input';
        input.setAttribute('data-station', s);
        row.appendChild(label);
        row.appendChild(input);
        mustDwellRow.appendChild(row);
      }
    }

    function earliestArrivalWithChoice(src, startTime, dst, dwell) {
      const INF = 1e9;
      const best = new Map();
      const pq = [];
      const push = (t, station, first, firstEdge) => {
        pq.push([t, station, first, firstEdge]);
        pq.sort((a, b) => a[0] - b[0]);
      };
      best.set(src, startTime);
      push(startTime, src, true, null);
      while (pq.length) {
        const [t, u, first, firstEdge] = pq.shift();
        if (t > (best.get(u) ?? INF)) continue;
        if (u === dst) return [t, firstEdge];
        const ready = first ? t : t + dwell;
        for (const e of edgesByFrom[u] || []) {
          if (e.dep < ready) continue;
          const nt = e.arr;
          if (nt < (best.get(e.dest) ?? INF)) {
            best.set(e.dest, nt);
            push(nt, e.dest, false, first ? e : firstEdge);
          }
        }
      }
      return null;
    }

    function solve(params) {
      const { start, end, startTime, endTime, mustList, excludeList, mustDwellMap } = params;
      const allowedSet = new Set(stations.filter((s) => !excludeList.has(s)));
      allowedSet.add(start);
      allowedSet.add(end);
      mustList.forEach((s) => allowedSet.add(s));

      const idx = new Map(stations.map((s, i) => [s, i]));
      const startIdx = idx.get(start);
      const endIdx = idx.get(end);

      let bestCount = 0;
      let bestPath = [];
      let found = false;

      const mustMask = mustList.reduce((m, s) => m | (1 << idx.get(s)), 0);
      const allowedMask = Array.from(allowedSet).reduce((m, s) => m | (1 << idx.get(s)), 0);

      // 取得每個必訪站的停留時間，預設 10
      const getDwell = (station) => (mustDwellMap && mustDwellMap[station] != null ? mustDwellMap[station] : 10);

      const returnCache = new Map();
      const key = (st, t) => `${st}|${Math.floor(t / 5) * 5}`;
      const canReturn = (st, t) => {
        const k = key(st, t);
        if (!returnCache.has(k)) {
          // 回程時，若是必訪站則用該站停留時間，否則 0
          const dwell = mustList.includes(st) ? getDwell(st) : 0;
          returnCache.set(k, earliestArrivalWithChoice(st, t + dwell, end, 0)?.[0] ?? null);
        }
        return returnCache.get(k);
      };

      function dfs(cur, t, visitedMask, path, arrived) {
        // 若目前站是必訪站且剛抵達，需停留 mustDwellMap[cur] 分鐘
        /*
        let dwell = 0;
        if (arrived && mustList.includes(cur)) {
          dwell = getDwell(cur);
        }
        */
        let dwell = arrived ? getDwell(cur) : 0;        
        const ea = canReturn(cur, t + dwell);
        if (ea !== null && ea <= endTime && (visitedMask & mustMask) === mustMask) {
          const visitedCnt = countBits(visitedMask & allowedMask);
          if (visitedCnt > bestCount) {
            bestCount = visitedCnt;
            bestPath = path.slice();
            found = true;
          }
        }

        const ready = t + dwell;
        for (const e of edgesByFrom[cur] || []) {
          if (e.dep < ready) continue;
          if (e.arr > endTime) continue;
          if (!allowedSet.has(e.dest)) continue;
          const vIdx = idx.get(e.dest);
          if (vIdx === endIdx && (visitedMask & (1 << endIdx))) continue;
          if (visitedMask & (1 << vIdx)) continue;
          // 若下一站是必訪站，抵達後也要停留 mustDwellMap[e.dest]
          //let nextDwell = mustList.includes(e.dest) ? getDwell(e.dest) : 0;
          let nextDwell = getDwell(e.dest);
          const ea2 = canReturn(e.dest, e.arr + nextDwell);
          if (ea2 === null || ea2 > endTime) continue;
          path.push(e);
          dfs(e.dest, e.arr, visitedMask | (1 << vIdx), path, true);
          path.pop();
        }
      }

      dfs(start, startTime, 1 << startIdx, [], false);
      return { bestCount, bestPath, found };
    }

    function countBits(n) {
      let c = 0;
      while (n) {
        c += n & 1;
        n >>= 1;
      }
      return c;
    }

    function parseList(val) {
      return val
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean);
    }


    function renderResult(params, result) {
      const { bestCount, bestPath, found } = result;
      if (!found) {
        outputEl.textContent = '無法在時窗內涵蓋所有必須造訪的站點。';
        document.getElementById('routeGrid').innerHTML = '';
        return;
      }
      // For return leg info and stay calc
      // 回程時，若最後一站是必訪站，需加上該站停留時間
      let lastDwell = 0;
      if (bestPath.length && params.mustList && params.mustDwellMap) {
        const last = bestPath[bestPath.length - 1].dest;
        if (params.mustList.includes(last)) lastDwell = params.mustDwellMap[last] || 10;
      }
      const retInfo = bestPath.length
        ? earliestArrivalWithChoice(
            bestPath[bestPath.length - 1].dest,
            bestPath[bestPath.length - 1].arr + lastDwell,
            params.end,
            0
          )
        : earliestArrivalWithChoice(params.start, params.startTime, params.end, 0);

      const stationWidth = Math.max(...stations.map((s) => s.length)) + 1;

      const lines = [];
      lines.push(`可造訪站數（含起點）: ${bestCount}`);
      let cur = params.start;
      let curT = params.startTime;
      for (let i = 0; i < bestPath.length; i++) {
        const e = bestPath[i];
        let nextDep = null;
        if (i + 1 < bestPath.length) nextDep = bestPath[i + 1].dep;
        else if (retInfo && retInfo[1]) nextDep = retInfo[1].dep;
        const stay = nextDep !== null ? Math.max(0, nextDep - e.arr) : null;
        const stayTxt = stay !== null ? fmtWait(stay) : 'stay N/A';
        lines.push(
          `${pad(cur, stationWidth)} ${fmtHHMM(curT).padStart(5)} -> [${e.train}] ${pad(e.origin, stationWidth)} ${fmtHHMM(
            e.dep
          ).padStart(5)} -> ${pad(e.dest, stationWidth)} ${fmtHHMM(e.arr).padStart(5)} | ${stayTxt.padStart(12)} at ${e.dest}`
        );
        cur = e.dest;
        curT = e.arr;
      }
      if (retInfo) {
        const [retArr, firstEdge] = retInfo;
        if (firstEdge) {
          lines.push(
            `${pad(cur, stationWidth)} ${fmtHHMM(curT).padStart(5)} -> [${firstEdge.train}] ${pad(
              firstEdge.origin,
              stationWidth
            )} ${fmtHHMM(firstEdge.dep).padStart(5)} -> ${pad(firstEdge.dest, stationWidth)} ${fmtHHMM(firstEdge.arr).padStart(5)}`
          );
        }
        lines.push(`抵達 ${params.end} ${fmtHHMM(retArr)}（截止 ${fmtHHMM(params.endTime)}）`);
      }
      outputEl.textContent = lines.join('\n');

      // --- Grid Visualization ---
      // Use desiredOrder for station order
      const desiredOrder = [
        '竹中', '上員', '榮華', '竹東', '橫山', '九讚頭', '合興', '富貴', '內灣',
      ];
      const gridStations = desiredOrder.filter(s => stations.includes(s));
      const N = gridStations.length;
      const rowH = 50;
      const marginT = 50;
      const marginB = 40;
      const routeCount = bestPath.length + ((retInfo && retInfo[1] && bestPath.length > 0 && bestPath[bestPath.length-1].dest !== params.end) ? 1 : 0);
      const W = 60 * (N - 1) + 60;
      const H = marginT + rowH * Math.max(1, routeCount) + marginB;
      // Map station name to x position
      const xMap = {};
      gridStations.forEach((s, i) => { xMap[s] = 30 + i * 60; });
      // Draw SVG
      let svg = `<svg width="${W}" height="${H}" style="background:#fff;">
        <defs>
          <marker id="arrow" markerWidth="6" markerHeight="6" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L6,3 L0,6 L2,3 Z" fill="#1976d2" />
          </marker>
        </defs>`;
      // Draw stations (empty circles) for each row
      for (let row = 0; row < Math.max(1, routeCount); row++) {
        gridStations.forEach((s, i) => {
          // 預設空心圓
          svg += `<circle cx="${xMap[s]}" cy="${marginT + row * rowH}" r="8" fill="#fff" stroke="#888" stroke-width="2" />`;
        });
      }
      // Draw station names at bottom
      gridStations.forEach((s, i) => {
        svg += `<text x="${xMap[s]}" y="${H-10}" text-anchor="middle" font-size="13">${s}</text>`;
      });
      // Draw route arrows, each on its own row
      let prev = params.start;
      let prevT = params.startTime;
      bestPath.forEach((e, idx) => {
        const rowY = marginT + idx * rowH;
        if (xMap[e.origin] !== undefined && xMap[e.dest] !== undefined) {
          // 填色起訖圓圈
          svg += `<circle cx="${xMap[e.origin]}" cy="${rowY}" r="8" fill="#1976d2" stroke="#1976d2" stroke-width="2" />`;
          svg += `<circle cx="${xMap[e.dest]}" cy="${rowY}" r="8" fill="#1976d2" stroke="#1976d2" stroke-width="2" />`;
          // 路線
          svg += `<line x1="${xMap[e.origin]}" y1="${rowY}" x2="${xMap[e.dest]}" y2="${rowY}" stroke="#1976d2" stroke-width="4" marker-end="url(#arrow)" />`;
          // 搭車與到站時間
          svg += `<text x="${xMap[e.origin]}" y="${rowY - 24}" text-anchor="middle" font-size="10" fill="#1976d2">${fmtHHMM(e.dep)}</text>`;
          svg += `<text x="${xMap[e.dest]}" y="${rowY - 24}" text-anchor="middle" font-size="10" fill="#1976d2">${fmtHHMM(e.arr)}</text>`;
          // Train label
          const xm = (xMap[e.origin] + xMap[e.dest]) / 2;
          svg += `<text x="${xm}" y="${rowY-15}" text-anchor="middle" font-size="12" fill="#1976d2">[${e.train}]</text>`;
          // 起點站名（圓心正上方）
          svg += `<text x="${xMap[e.origin]}" y="${rowY - 10}" text-anchor="middle" font-size="12" fill="#333">${e.origin}</text>`;
          // 終點站名（圓心正上方）
          svg += `<text x="${xMap[e.dest]}" y="${rowY - 10}" text-anchor="middle" font-size="12" fill="#333">${e.dest}</text>`;
        }
        prev = e.dest;
        prevT = e.arr;
      });
      // Draw return leg if exists, on next row
      if (retInfo && retInfo[1] && xMap[prev] !== undefined && xMap[params.end] !== undefined && prev !== params.end) {
        const e = retInfo[1];
        const rowY = marginT + bestPath.length * rowH;
        // 填色起訖圓圈
        svg += `<circle cx="${xMap[prev]}" cy="${rowY}" r="8" fill="#1976d2" stroke="#1976d2" stroke-width="2" />`;
        svg += `<circle cx="${xMap[params.end]}" cy="${rowY}" r="8" fill="#1976d2" stroke="#1976d2" stroke-width="2" />`;
        // 路線
        svg += `<line x1="${xMap[prev]}" y1="${rowY}" x2="${xMap[params.end]}" y2="${rowY}" stroke="#1976d2" stroke-width="4" marker-end="url(#arrow)" />`;
        // 搭車與到站時間
        svg += `<text x="${xMap[prev]}" y="${rowY - 24}" text-anchor="middle" font-size="10" fill="#1976d2">${fmtHHMM(e.dep)}</text>`;
        svg += `<text x="${xMap[params.end]}" y="${rowY - 24}" text-anchor="middle" font-size="10" fill="#1976d2">${fmtHHMM(e.arr)}</text>`;
        // Train label
        const xm = (xMap[prev] + xMap[params.end]) / 2;
        svg += `<text x="${xm}" y="${rowY-15}" text-anchor="middle" font-size="12" fill="#1976d2">[${e.train}]</text>`;
        // 起點站名（圓心正上方）
        svg += `<text x="${xMap[prev]}" y="${rowY - 10}" text-anchor="middle" font-size="12" fill="#333">${prev}</text>`;
        // 終點站名（圓心正上方）
        svg += `<text x="${xMap[params.end]}" y="${rowY - 10}" text-anchor="middle" font-size="12" fill="#333">${params.end}</text>`;
      }
      svg += `</svg>`;
      document.getElementById('routeGrid').innerHTML = svg;
    }

    document.getElementById('solveBtn').addEventListener('click', () => {
      try {
        const start = startSel.value;
        const end = endSel.value || start;
        const startTime = parseHHMM(document.getElementById('startTime').value || '07:00');
        const endTime = parseHHMM(document.getElementById('endTime').value || '09:30');
        const mustList = Array.from(document.querySelectorAll('input[name="must"]:checked')).map((el) => el.value);
        const excludeList = new Set(
          Array.from(document.querySelectorAll('input[name="exclude"]:checked')).map((el) => el.value)
        );

        // Resolve conflicts: if a station is both must and exclude, prefer must and drop it from exclude.
        const overlap = mustList.filter((s) => excludeList.has(s));
        if (overlap.length) {
          overlap.forEach((s) => excludeList.delete(s));
          statusEl.textContent = `已自動移除排除與必訪重疊: ${overlap.join(', ')}`;
        }

        if (!stations.includes(start) || !stations.includes(end)) {
          outputEl.textContent = '起訖站不在時刻表內';
          return;
        }
        for (const s of mustList) {
          if (!stations.includes(s)) {
            outputEl.textContent = `必須站點不存在: ${s}`;
            return;
          }
        }

        // 取得每個必訪站的停留時間
        const mustDwellInputs = Array.from(document.querySelectorAll('.must-dwell-input'));
        const mustDwellMap = {};
        for (const input of mustDwellInputs) {
          const st = input.getAttribute('data-station');
          mustDwellMap[st] = Number(input.value) || 10;
        }

        const res = solve({ start, end, startTime, endTime, mustList, excludeList, mustDwellMap });
        renderResult({ start, end, startTime, endTime, mustList, mustDwellMap }, res);
      } catch (err) {
        outputEl.textContent = '錯誤: ' + err.message;
      }
    });

    loadData().catch((err) => {
      statusEl.textContent = 'Load error: ' + err.message;
    });
  </script>
</body>
</html>
